<!DOCTYPE html>
<html lang="en" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  数据结构与算法笔记
  #



  第一章 引论
  #

如果说编程语言是程序员的招式，那么数据结构和算法就相当于程序员的内功。所以要学好数据结构和算法，写这篇笔记的目的是为了自我不断积累。不积跬步，无以至千里！

  1.1 数学知识复习
  #


  1.1.1 指数
  #



  1.1.2 对数
  #


在计算机科学中，除非有特别的声明，所有的对数都是以 2 为底的

记住：log 1 = 0，log 2 = 1，log 1024 = 10， log 1048576 = 20

  1.1.3 级数
  #



  1.1.4 模运算
  #

如果 N 整除 A - B，那么就说 A 与 B 模 N 同余，记为 A ≡ B（mod N）

  1.1.5 证明方法
  #


证明数据结构分析中的结论的两个最常用的方法是归纳法和反证法，证明一个定理不成立的最好的方法是举出一个反例。">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/docs/learm/go-to-class/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/">
  <meta property="og:site_name" content="Alex lan">
  <meta property="og:title" content="算法与数据结构笔记">
  <meta property="og:description" content="数据结构与算法笔记#第一章 引论#如果说编程语言是程序员的招式，那么数据结构和算法就相当于程序员的内功。所以要学好数据结构和算法，写这篇笔记的目的是为了自我不断积累。不积跬步，无以至千里！
1.1 数学知识复习#1.1.1 指数#1.1.2 对数#在计算机科学中，除非有特别的声明，所有的对数都是以 2 为底的
记住：log 1 = 0，log 2 = 1，log 1024 = 10， log 1048576 = 20
1.1.3 级数#1.1.4 模运算#如果 N 整除 A - B，那么就说 A 与 B 模 N 同余，记为 A ≡ B（mod N）
1.1.5 证明方法#证明数据结构分析中的结论的两个最常用的方法是归纳法和反证法，证明一个定理不成立的最好的方法是举出一个反例。">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
    <meta property="article:published_time" content="2024-12-08T14:03:24+08:00">
    <meta property="article:modified_time" content="2024-12-08T14:03:24+08:00">
    <meta property="article:tag" content="老实上课">
<title>算法与数据结构笔记 | Alex lan</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/docs/learm/go-to-class/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/">
<link rel="stylesheet" href="/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css" integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.a389106ec8847d561d666791d134c44fe525dae19e4a1107009df60a9bb4c157.js" integrity="sha256-o4kQbsiEfVYdZmeR0TTET&#43;Ul2uGeShEHAJ32Cpu0wVc=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>Alex lan</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>















  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-867144600acf9658ad1e030dba887392" class="toggle"  />
    <label for="section-867144600acf9658ad1e030dba887392" class="flex justify-between">
      <a role="button" class="">code</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-bad47914f28bea05b9a99cdd87cd69fb" class="toggle"  />
    <label for="section-bad47914f28bea05b9a99cdd87cd69fb" class="flex justify-between">
      <a role="button" class="">Android</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/code/android/ui/" class="">Android ui</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/android/%E5%8D%8F%E7%A8%8B-retrofit/" class="">Android 协程-retrofit</a>
  

        </li>
      
    
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/android/%E6%AF%94%E8%B5%9B/" class="">Android 比赛</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/android/2024%E5%B9%B4-%E6%96%B0/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" class="">android 碎念</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/android/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" class="">Android 网络请求</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/android/2024%E5%B9%B4-%E6%96%B0/%E9%80%82%E9%85%8D%E5%99%A8/" class="">Android 适配器</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/android/2024%E5%B9%B4-%E6%96%B0/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" class="">Android-网络请求</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-4c67168a533057d7cb02259caca8884d" class="toggle"  />
    <label for="section-4c67168a533057d7cb02259caca8884d" class="flex justify-between">
      <a role="button" class="">linux</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/code/linux/screen/" class="">linux screen</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-227bbb535145acab9a03ddf223110bf7" class="toggle"  />
    <label for="section-227bbb535145acab9a03ddf223110bf7" class="flex justify-between">
      <a role="button" class="">鸿蒙</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/code/harmony/tabbar/" class="">鸿蒙开发-TbaBar</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/harmony/%E5%85%A5%E9%97%A8/" class="">鸿蒙开发-入门</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/harmony/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/" class="">鸿蒙开发-状态管理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/harmony/%E7%BD%91%E7%BB%9C/" class="">鸿蒙开发-网络请求</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2fdeba3d7ff97db6bc8b47fcb3b9c1c7" class="toggle"  />
    <label for="section-2fdeba3d7ff97db6bc8b47fcb3b9c1c7" class="flex justify-between">
      <a role="button" class="">ee</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/code/new/autotakepic_flask/" class="">Auto Take Pic Flask</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/new/c_%E7%94%9C%E7%94%9C%E5%9C%88/" class="">C 甜甜圈</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/new/rust/%E6%9F%90%E5%9B%BE/" class="">某图</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/new/%E4%BD%9C%E4%B8%9A2023.10.10/" class="">作业2023.10.10</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/new/%E6%98%9F%E4%BA%91%E5%8A%A0%E9%80%9F%E5%99%A8/" class="">星云加速器</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/new/%E6%9C%A8%E9%A9%AC%E7%99%BB%E9%99%86/" class="">木马登陆</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/new/%E6%9F%90update/" class="">某update</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/new/%E6%9F%90%E5%88%B7%E8%AF%BE/" class="">某刷课</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/new/%E6%9F%90%E6%B4%97%E8%A1%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F/" class="">某洗衣小程序</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/new/%E9%82%A3%E4%BA%9B%E9%AA%9A%E6%93%8D%E4%BD%9C/" class="">那些骚操作</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/arch-linux/" class="">arch linux</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/avaloniaui/" class="">avaloniaui</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/c-sharp/" class="">c#</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/java_mysql/" class="">Java_mysql</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/linux%E7%9F%A5%E8%AF%86/" class="">linux知识</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/mqtt--%E4%B8%B2%E5%8F%A3--4055/" class="">MQTT &amp;&amp; 串口</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/python/" class="">Python</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/rust/" class="">rust</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/cmd/" class="">Cmd</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/dart/" class="">Dart</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/code/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="">数据库</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-a88931adc275b5db7ba2257eca8098f2" class="toggle"  />
    <label for="section-a88931adc275b5db7ba2257eca8098f2" class="flex justify-between">
      <a role="button" class="">e .wp</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/wp/bili_22_1024/" class="">bili_22_1024</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/wp/love_math/" class="">LOVE_math</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/wp/webexercise/ruby_cookie/" class="">ruby_cookie</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-bc5bfc4ab3726cdac08770524fbd5e52" class="toggle"  />
    <label for="section-bc5bfc4ab3726cdac08770524fbd5e52" class="flex justify-between">
      <a role="button" class="">hack</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/hack/msf/" class="">msf</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/hack/thefatrat/" class="">TheFatRat</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c809dbac7a9b531c0deb3f94bb3a5eb9" class="toggle"  />
    <label for="section-c809dbac7a9b531c0deb3f94bb3a5eb9" class="flex justify-between">
      <a href="/docs/re/" class="">re</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-59835f29e02875febbf77853a8373c43" class="toggle"  />
    <label for="section-59835f29e02875febbf77853a8373c43" class="flex justify-between">
      <a href="/docs/re/new/" class="">demo</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/re/new/%E6%9F%90h%E8%A7%86%E9%A2%91%E8%BD%AF%E4%BB%B6/" class="">Android 比赛</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/re/new/u%E5%87%80/" class="">u净</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/re/new/%E5%A4%A7%E5%AD%A6%E6%90%9C%E9%A2%98%E9%85%B1/" class="">大学搜题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/re/new/%E5%B1%B1%E8%A5%BF%E6%81%92%E5%AE%89%E5%88%B7%E8%AF%BE%E4%BB%A5%E5%8F%8A%E8%80%83%E8%AF%95/" class="">山西恒安刷课以及考试</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/re/new/%E6%9F%90h%E8%BD%AF%E4%BB%B6/" class="">某h软件</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/re/new/bika/" class="">某h软件 bika</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/re/new/%E6%9F%90h%E8%BD%AF%E4%BB%B6-2/" class="">某h软件-2</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/re/new/%E6%B7%98%E9%87%91%E7%A4%BE%E5%8C%BA%E7%99%BB%E9%99%86/" class="">淘金社区登陆</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/re/new/%E7%88%B1%E5%A4%9A%E5%A4%9A-%E5%88%86%E6%9E%90/" class="">爱多多 分析</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/re/new/%E7%A5%9E%E5%9B%BE%E5%A3%81%E7%BA%B8/" class="">神图壁纸</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/re/arm%E6%B1%87%E7%BC%96/" class="">arm 汇编</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/re/flutter---blutter/" class="">flutter - blutter</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/re/flutter/" class="">flutter 初探</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/re/frida/" class="">frida</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/re/ida%E5%8A%A8%E8%B0%83so/" class="">ida 动态调试so</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/re/%E5%8F%8D%E7%BC%96%E8%AF%91/" class="">反编译</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/re/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%86%E5%90%91/" class="">小程序 逆向</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-d633b3f91ad6faec5e15f38ac64d5024" class="toggle" checked />
    <label for="section-d633b3f91ad6faec5e15f38ac64d5024" class="flex justify-between">
      <a href="/docs/learm/" class="">学习</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-297a8c491188fdc1e4d5049993bd118b" class="toggle"  />
    <label for="section-297a8c491188fdc1e4d5049993bd118b" class="flex justify-between">
      <a role="button" class="">english</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/learm/english/%E4%B8%80%E8%88%AC%E7%8E%B0%E5%9C%A8%E6%97%B6/" class="">一般现在时</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/learm/english/%E7%8E%B0%E5%9C%A8%E8%BF%9B%E8%A1%8C%E6%97%B6/" class="">现在进行时</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-d273ec3342c86bd09d8e0a595cc7603e" class="toggle"  />
    <label for="section-d273ec3342c86bd09d8e0a595cc7603e" class="flex justify-between">
      <a role="button" class="">math</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/learm/math/%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95/" class="">公式测试</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/learm/math/%E5%9F%BA%E6%9C%AC%E7%A7%AF%E5%88%86/" class="">基本积分</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/learm/math/%E5%AF%BC%E6%95%B0/" class="">导数</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/learm/math/%E6%95%B0%E5%88%97/" class="">数列</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/learm/math/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95/" class="">数学公式测试</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/learm/math/%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F/" class="">泰勒公式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/learm/math/%E7%AD%89%E4%BB%B7%E6%97%A0%E7%A9%B7%E5%B0%8F/" class="">等价无穷小</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/learm/math/%E9%B8%A1%E6%9D%82%E5%85%AC%E5%BC%8F/" class="">鸡杂公式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-ea5b2994c4cca97c0834172637987408" class="toggle" checked />
    <label for="section-ea5b2994c4cca97c0834172637987408" class="flex justify-between">
      <a role="button" class="">上课</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/learm/go-to-class/java/" class="">java</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/learm/go-to-class/linux/" class="">linux</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/learm/go-to-class/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" class="">信息安全</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/learm/go-to-class/%E5%B1%80%E5%9F%9F%E7%BD%91-%E6%80%9D%E7%A7%91-pt/" class="">局域网 思科 pt</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/learm/go-to-class/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/" class="active">算法与数据结构笔记</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/learm/go-to-class/%E7%BD%91%E9%A1%B5%E5%88%B6%E4%BD%9C/" class="">网页制作</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-a9ce434c78e2b2b70812ee1671233fb4" class="toggle"  />
    <label for="section-a9ce434c78e2b2b70812ee1671233fb4" class="flex justify-between">
      <a role="button" class="">网络安全</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3bf12ad5664ebca7e9060559169913cd" class="toggle"  />
    <label for="section-3bf12ad5664ebca7e9060559169913cd" class="flex justify-between">
      <a role="button" class="">java</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/java/sql%E6%B3%A8%E5%85%A5/" class="">java sql 注入</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/java/web-inf%E8%AF%BB%E5%8F%96/" class="">WEB-INF 读取</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/java/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" class="">反序列化</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c7fff2b0fc43407720940cd3bd5fa3fa" class="toggle"  />
    <label for="section-c7fff2b0fc43407720940cd3bd5fa3fa" class="flex justify-between">
      <a role="button" class="">node</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/node/%E5%8E%9F%E5%BD%A2%E9%93%BE%E6%B1%A1%E6%9F%93/" class="">node 原型链污染</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-5385b8bcbe311a5d908dc263de46f07f" class="toggle"  />
    <label for="section-5385b8bcbe311a5d908dc263de46f07f" class="flex justify-between">
      <a role="button" class="">other</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/other/linux/" class="">linux 知识点</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/other/xpath%E6%B3%A8%E5%85%A5/" class="">xpath 注入</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/other/xxe/" class="">XXE</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/other/%E5%8F%8D%E5%BC%B9shll/" class="">反弹shell</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/other/%E7%AB%AF%E5%8F%A3/" class="">常见端口</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-46a6c3a4b470bf639b30aeb9a16a1257" class="toggle"  />
    <label for="section-46a6c3a4b470bf639b30aeb9a16a1257" class="flex justify-between">
      <a role="button" class="">php</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/php/php/" class="">php</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/php/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" class="">php</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/php/php%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8Clinux%E7%BB%95%E8%BF%87/" class="">php命令执行linux绕过</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/php/readflag/" class="">readflag</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/php/sql%E6%B3%A8%E5%85%A5/regexp%E7%9B%B2%E6%B3%A8/" class="">regexp盲注</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/php/session%E4%BC%AA%E9%80%A0/" class="">session伪造</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/php/sql%E6%B3%A8%E5%85%A5/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/" class="">堆叠注入</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/php/sql%E6%B3%A8%E5%85%A5/%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%B3%A8%E5%85%A5/" class="">字符型注入</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/php/sql%E6%B3%A8%E5%85%A5/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/" class="">报错注入</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/php/sql%E6%B3%A8%E5%85%A5/%E6%95%B4%E5%9E%8B%E6%B3%A8%E5%85%A5/" class="">整型注入</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/php/sql%E6%B3%A8%E5%85%A5/%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/" class="">时间注入</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/php/sql%E6%B3%A8%E5%85%A5/%E7%9B%B2%E6%B3%A8/" class="">盲注</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/php/htaccess%E7%9A%84%E5%88%A9%E7%94%A8/" class="">Htaccess的利用</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/php/md5%E7%A2%B0%E6%92%9E/" class="">Md5碰撞</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/php/%E4%BC%AA%E5%8D%8F%E8%AE%AE/" class="">伪协议</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/php/%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E/" class="">函数漏洞</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/php/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" class="">文件上传</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/php/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/" class="">文件包含</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-dbfc22e2e7caa67fee4f381ec66fd790" class="toggle"  />
    <label for="section-dbfc22e2e7caa67fee4f381ec66fd790" class="flex justify-between">
      <a role="button" class="">python</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/python/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" class="">pickle反序列化</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/python/python-session%E4%BC%AA%E9%80%A0/" class="">python session伪造</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/python/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/" class="">SSTI模板注入</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-27bef856708365c3f954dc367d1bca66" class="toggle"  />
    <label for="section-27bef856708365c3f954dc367d1bca66" class="flex justify-between">
      <a role="button" class="">tools</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/network-security/tools/fake-mysql/" class="">fake-mysql</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-02af837b39c34c4496ee7c45850c4389" class="toggle"  />
    <label for="section-02af837b39c34c4496ee7c45850c4389" class="flex justify-between">
      <a role="button" class="">index</a>
    </label>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>










  
<ul>
  
  <li>
    <a href="/posts/"  >
        Blog
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>算法与数据结构笔记</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#第一章-引论">第一章 引论</a>
      <ul>
        <li><a href="#11-数学知识复习">1.1 数学知识复习</a></li>
        <li><a href="#12-递归简论">1.2 递归简论</a></li>
        <li><a href="#13-数据结构的概念">1.3 数据结构的概念</a></li>
      </ul>
    </li>
    <li><a href="#第二章-算法分析">第二章 算法分析</a>
      <ul>
        <li><a href="#21-算法的概念">2.1 算法的概念</a></li>
        <li><a href="#22-数学基础">2.2 数学基础</a></li>
        <li><a href="#23-计算模型">2.3 计算模型</a></li>
        <li><a href="#24-算法效率的度量">2.4 算法效率的度量</a></li>
        <li><a href="#25-分析问题">2.5 分析问题</a></li>
      </ul>
    </li>
    <li><a href="#第三章-线性表">第三章 线性表</a>
      <ul>
        <li><a href="#31-抽象数据类型adt">3.1 抽象数据类型(ADT)</a></li>
        <li><a href="#32-顺序表">3.2 顺序表</a></li>
        <li><a href="#33-链式表">3.3 链式表</a></li>
      </ul>
    </li>
    <li><a href="#第四章-栈和队列">第四章 栈和队列</a>
      <ul>
        <li><a href="#41-栈">4.1 栈</a></li>
        <li><a href="#42-队列">4.2 队列</a></li>
      </ul>
    </li>
    <li><a href="#第五章-树">第五章 树</a>
      <ul>
        <li><a href="#基本概念">基本概念</a></li>
        <li><a href="#树的性质">树的性质</a></li>
        <li><a href="#二叉树定义">二叉树定义</a></li>
        <li><a href="#二叉树性质">二叉树性质</a></li>
        <li><a href="#二叉树存储">二叉树存储</a></li>
        <li><a href="#二叉树遍历">二叉树遍历</a></li>
        <li><a href="#遍历序列构造二叉树">遍历序列构造二叉树</a></li>
        <li><a href="#线索二叉树">线索二叉树</a></li>
        <li><a href="#树的存储">树的存储</a></li>
        <li><a href="#树森林与二叉树的转换">树、森林与二叉树的转换</a></li>
        <li><a href="#树的遍历">树的遍历</a></li>
        <li><a href="#森林的遍历">森林的遍历</a></li>
        <li><a href="#遍历序列的对应关系">遍历序列的对应关系</a></li>
        <li><a href="#树的应用-并查集">树的应用-并查集</a></li>
        <li><a href="#树的应用-二叉排序树">树的应用-二叉排序树</a></li>
      </ul>
    </li>
    <li><a href="#第六章-散列">第六章 散列</a></li>
    <li><a href="#第七章-优先队列堆">第七章 优先队列（堆）</a></li>
    <li><a href="#第八章-排序">第八章 排序</a>
      <ul>
        <li><a href="#81--排序算法简述">8.1  排序算法简述</a></li>
        <li><a href="#82-插入排序">8.2 插入排序</a></li>
        <li><a href="#83-交换排序">8.3 交换排序</a></li>
        <li><a href="#84-选择排序">8.4 选择排序</a></li>
        <li><a href="#85-归并排序">8.5 归并排序</a></li>
        <li><a href="#86-基数排序">8.6 基数排序</a></li>
      </ul>
    </li>
    <li><a href="#第九章-查找">第九章 查找</a>
      <ul>
        <li><a href="#91-二分查找">9.1 二分查找</a></li>
        <li><a href="#92-散列查找">9.2 散列查找</a></li>
      </ul>
    </li>
    <li><a href="#第十章-不相交集">第十章 不相交集</a></li>
    <li><a href="#第十一章-图论算法">第十一章 图论算法</a></li>
    <li><a href="#第十二章-算法设计技巧">第十二章 算法设计技巧</a></li>
    <li><a href="#第十三章-摊还分析">第十三章 摊还分析</a></li>
    <li><a href="#第十四章-高级数据结构及其实现">第十四章 高级数据结构及其实现</a></li>
    <li><a href="#矩阵的压缩存储">矩阵的压缩存储</a>
      <ul>
        <li><a href="#对称矩阵">对称矩阵</a></li>
        <li><a href="#三角矩阵">三角矩阵</a></li>
        <li><a href="#三对角矩阵">三对角矩阵</a></li>
        <li><a href="#稀疏矩阵">稀疏矩阵</a></li>
      </ul>
    </li>
    <li><a href="#kmp算法">KMP算法</a>
      <ul>
        <li><a href="#手搓步骤">手搓步骤</a></li>
        <li><a href="#算法实现">算法实现</a></li>
      </ul>
    </li>
    <li><a href="#回溯算法">回溯算法</a>
      <ul>
        <li><a href="#八皇后问题">八皇后问题</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="数据结构与算法笔记">
  数据结构与算法笔记
  <a class="anchor" href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%e7%ac%94%e8%ae%b0">#</a>
</h1>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/NoteBook/20200613211202.png" alt="image-20200613211201429" /></p>
<h2 id="第一章-引论">
  第一章 引论
  <a class="anchor" href="#%e7%ac%ac%e4%b8%80%e7%ab%a0-%e5%bc%95%e8%ae%ba">#</a>
</h2>
<p>如果说编程语言是程序员的招式，那么数据结构和算法就相当于程序员的内功。所以要学好数据结构和算法，写这篇笔记的目的是为了自我不断积累。不积跬步，无以至千里！</p>
<h3 id="11-数学知识复习">
  1.1 数学知识复习
  <a class="anchor" href="#11-%e6%95%b0%e5%ad%a6%e7%9f%a5%e8%af%86%e5%a4%8d%e4%b9%a0">#</a>
</h3>
<h4 id="111-指数">
  1.1.1 指数
  <a class="anchor" href="#111-%e6%8c%87%e6%95%b0">#</a>
</h4>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180521.png" alt="image-20200402115827829" /></p>
<h4 id="112-对数">
  1.1.2 对数
  <a class="anchor" href="#112-%e5%af%b9%e6%95%b0">#</a>
</h4>
<blockquote>
<p>在计算机科学中，除非有特别的声明，所有的对数都是以 2 为底的</p>
</blockquote>
<p>记住：log 1 = 0，log 2 = 1，log 1024 = 10， log 1048576 = 20</p>
<h4 id="113-级数">
  1.1.3 级数
  <a class="anchor" href="#113-%e7%ba%a7%e6%95%b0">#</a>
</h4>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180512.png" alt="image-20200402120447323" /></p>
<h4 id="114-模运算">
  1.1.4 模运算
  <a class="anchor" href="#114-%e6%a8%a1%e8%bf%90%e7%ae%97">#</a>
</h4>
<p>如果 N 整除 A - B，那么就说 A 与 B 模 N 同余，记为 A ≡ B（mod N）</p>
<h4 id="115-证明方法">
  1.1.5 证明方法
  <a class="anchor" href="#115-%e8%af%81%e6%98%8e%e6%96%b9%e6%b3%95">#</a>
</h4>
<blockquote>
<p>证明数据结构分析中的结论的两个最常用的方法是归纳法和反证法，证明一个定理不成立的最好的方法是举出一个反例。</p>
</blockquote>
<ul>
<li>归纳法证明</li>
</ul>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180530.png" alt="image-20200402121314240" /></p>
<ul>
<li>反证法证明</li>
</ul>
<h3 id="12-递归简论">
  1.2 递归简论
  <a class="anchor" href="#12-%e9%80%92%e5%bd%92%e7%ae%80%e8%ae%ba">#</a>
</h3>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180533.png" alt="image-20200402131718991" /></p>
<h4 id="121-打印输出数">
  1.2.1 打印输出数
  <a class="anchor" href="#121-%e6%89%93%e5%8d%b0%e8%be%93%e5%87%ba%e6%95%b0">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printOut</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(n <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">10</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printOut</span>(n <span style="color:#f92672">/</span> <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, n <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> n, result;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printOut</span>(n);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="13-数据结构的概念">
  1.3 数据结构的概念
  <a class="anchor" href="#13-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e7%9a%84%e6%a6%82%e5%bf%b5">#</a>
</h3>
<p><code>程序 = 数据结构 + 算法</code> 是由 N.Wirth（沃斯）提出来的。</p>
<ul>
<li>数据结构指的是数据与数据之间的逻辑关系</li>
<li>算法指的是解决特定问题的步骤和方法</li>
</ul>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180538.png" alt="image-20200401201852656" /></p>
<blockquote>
<p>理解下面三点：</p>
</blockquote>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180542.png" alt="image-20200401201304869" /></p>
<h2 id="第二章-算法分析">
  第二章 算法分析
  <a class="anchor" href="#%e7%ac%ac%e4%ba%8c%e7%ab%a0-%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90">#</a>
</h2>
<blockquote>
<p>算法（algorithm）是为求解一个问题需要遵循的、被清楚地指定的简单指令的集合。对于一个问题，一旦给定某种算法并且（以某种方式）确定其是正确的，那么重要的一步就是确定该算法将需要多少诸如时间或者空间等资源量的问题。</p>
</blockquote>
<h3 id="21-算法的概念">
  2.1 算法的概念
  <a class="anchor" href="#21-%e7%ae%97%e6%b3%95%e7%9a%84%e6%a6%82%e5%bf%b5">#</a>
</h3>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180546.png" alt="" /></p>
<h3 id="22-数学基础">
  2.2 数学基础
  <a class="anchor" href="#22-%e6%95%b0%e5%ad%a6%e5%9f%ba%e7%a1%80">#</a>
</h3>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180555.png" alt="image-20200402133657321" /></p>
<h3 id="23-计算模型">
  2.3 计算模型
  <a class="anchor" href="#23-%e8%ae%a1%e7%ae%97%e6%a8%a1%e5%9e%8b">#</a>
</h3>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180559.png" alt="image-20200402133836771" /></p>
<h3 id="24-算法效率的度量">
  2.4 算法效率的度量
  <a class="anchor" href="#24-%e7%ae%97%e6%b3%95%e6%95%88%e7%8e%87%e7%9a%84%e5%ba%a6%e9%87%8f">#</a>
</h3>
<h4 id="241-时间复杂度">
  2.4.1 时间复杂度
  <a class="anchor" href="#241-%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6">#</a>
</h4>
<p>!&gt; 如何评估算法时间开销？</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180602.png" alt="image-20200401203235581" /></p>
<p>所以要进行事前预估，事前预估算法时间开销 T(n) 与问题规模n的关系 (T表示“time”)</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180605.png" alt="" /></p>
<p><strong>时间复杂度量级比较</strong>
$$
O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)
$$
<img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180609.png" alt="" /></p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180613.png" alt="" /></p>
<h4 id="242-空间复杂度">
  2.4.2 空间复杂度
  <a class="anchor" href="#242-%e7%a9%ba%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6">#</a>
</h4>
<p>算法可以<strong>原地工作</strong>——S(n)=O(1)</p>
<p>计算规则与时间复杂度类似</p>
<p>递归型算法</p>
<p>空间复杂度=递归调用的深度</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180617.png" alt="" /></p>
<h3 id="25-分析问题">
  2.5 分析问题
  <a class="anchor" href="#25-%e5%88%86%e6%9e%90%e9%97%ae%e9%a2%98">#</a>
</h3>
<h4 id="251-最大子序列和">
  2.5.1 最大子序列和
  <a class="anchor" href="#251-%e6%9c%80%e5%a4%a7%e5%ad%90%e5%ba%8f%e5%88%97%e5%92%8c">#</a>
</h4>
<p>【题目】</p>
<pre tabindex="0"><code>给定（可能有负数）整数a(1)、a(2)、……a(n)，求 a(1)+a(2)+……+a(j)的最大值。
为方便起见，若所有的整数为负数，则最大子序列和为0.

也就是：在一系列整数中，找出连续的若干个整数，这若干个整数之和 最大。
</code></pre><p>【代码实现】</p>
<ul>
<li>方法一：穷举法
<ul>
<li>穷举所有可能，由于嵌套三层 for 循环，运行时间 O(N^3)</li>
<li>算法思想：算出每个子序列的和，即算出序列中第 i 个到第 j 个数的和 (j &gt;= i) ，并进行比较</li>
</ul>
</li>
<li>C 语言版：函数原型为 int maxSubSum(int a[]);</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxSubSum</span>(<span style="color:#66d9ef">int</span> a[]){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> maxSum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> sum, i, j, k;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(a) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(j <span style="color:#f92672">=</span> i; j <span style="color:#f92672">&lt;</span> len; j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>			sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span>(k <span style="color:#f92672">=</span> i; k <span style="color:#f92672">&lt;=</span> j; k<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>				sum <span style="color:#f92672">+=</span> a[k];<span style="color:#75715e">//计算 a[i] 到 a[j] 的和 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(sum <span style="color:#f92672">&gt;</span> maxSum){
</span></span><span style="display:flex;"><span>				maxSum <span style="color:#f92672">=</span> sum;
</span></span><span style="display:flex;"><span>			} 
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> maxSum;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> a[] <span style="color:#f92672">=</span> {<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">11</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">13</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">5</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>};
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> max <span style="color:#f92672">=</span> <span style="color:#a6e22e">maxSubSum</span>(a);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,max);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>C 语言版：函数原型为 int maxSubSum(int a[], int n);</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxSubSum</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> maxSum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> sum, i, j, k;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(j <span style="color:#f92672">=</span> i; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>			sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span>(k <span style="color:#f92672">=</span> i; k <span style="color:#f92672">&lt;=</span> j; k<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>				sum <span style="color:#f92672">+=</span> a[k];<span style="color:#75715e">//计算 a[i] 到 a[j] 的和 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(sum <span style="color:#f92672">&gt;</span> maxSum){
</span></span><span style="display:flex;"><span>				maxSum <span style="color:#f92672">=</span> sum;
</span></span><span style="display:flex;"><span>			} 
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> maxSum;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//int a[] = {-2, 11, -4, 13, -5, -2};
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> a[] <span style="color:#f92672">=</span> { <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">1</span> };
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(a) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>);<span style="color:#75715e">//有负数所以 strlen(a) 不能用 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> max <span style="color:#f92672">=</span> <span style="color:#a6e22e">maxSubSum</span>(a, len);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,max);	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p>方法二：</p>
<ul>
<li>在第一种的基础上简化，撤除一层 for 循环，运行时间 O(N^2)</li>
<li>算法思想：第一个算法的第三个 for 循环中有大量不必要的重复计算，如：计算 i 到 j 的和，然而 i 到 j-1 的和在前一次的循环中已经计算过，无需重复计算，故该 for 循环可以去掉</li>
</ul>
</li>
<li>
<p>C 语言版</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxSubSum</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> maxSum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> sum, i, j;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>		sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(j <span style="color:#f92672">=</span> i; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>			sum <span style="color:#f92672">+=</span> a[j];
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(sum <span style="color:#f92672">&gt;</span> maxSum){
</span></span><span style="display:flex;"><span>				maxSum <span style="color:#f92672">=</span> sum;
</span></span><span style="display:flex;"><span>			} 
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> maxSum;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//int a[] = {-2, 11, -4, 13, -5, -2};
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> a[] <span style="color:#f92672">=</span> { <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">1</span> };
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(a) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>);<span style="color:#75715e">//有负数所以 strlen(a) 不能用 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> max <span style="color:#f92672">=</span> <span style="color:#a6e22e">maxSubSum</span>(a, len);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,max);	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>方法三：分而治之
<ul>
<li>算法思想：把问题分成两个大致相等的子问题，然后递归地对它们求解，这是“分”的部分。“治”阶段将两个子问题的解修补到一起并可能再做些少量的附加工作，最后得到整个问题的解。</li>
<li>在该问题中，如果把序列从中间分为两部分，那么最大子序列和可能在三处出现，要么整个出现在输入数据的左半部，要么整个出现在右半部，要么跨越分界线。前两种情况可以递归求解，第三种情况的最大和可以通过求出前半部分（包括前半部分的最后一个元素）的最大和以及后半部分（包含后半部分的第一个元素）的最大和而得到，此时将两个和相加。</li>
<li>运行时间 O( N log N )</li>
</ul>
</li>
<li>C 语言版</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxSubSum</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> right){
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断是否只有一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (left <span style="color:#f92672">==</span> right) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (a[left] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> a[left];
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> center <span style="color:#f92672">=</span> (left <span style="color:#f92672">+</span> right) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxLeftSum <span style="color:#f92672">=</span> <span style="color:#a6e22e">maxSubSum</span>(a, left, center);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxRightSum <span style="color:#f92672">=</span> <span style="color:#a6e22e">maxSubSum</span>(a, center <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, right);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 左端处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> maxLeftBorderSum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> leftBorderSum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> center; i <span style="color:#f92672">&gt;=</span> left; i<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>    	leftBorderSum <span style="color:#f92672">+=</span> a[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (leftBorderSum <span style="color:#f92672">&gt;</span> maxLeftBorderSum) {
</span></span><span style="display:flex;"><span>            maxLeftBorderSum <span style="color:#f92672">=</span> leftBorderSum;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 右端处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> maxRightBorderSum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rightBorderSum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> center <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> right; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        rightBorderSum <span style="color:#f92672">+=</span> a[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (rightBorderSum <span style="color:#f92672">&gt;</span> maxRightBorderSum) {
</span></span><span style="display:flex;"><span>            maxRightBorderSum <span style="color:#f92672">=</span> rightBorderSum;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 返回最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> maxBorderSum <span style="color:#f92672">=</span> maxLeftBorderSum <span style="color:#f92672">+</span> maxRightBorderSum;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> maxBorderSum <span style="color:#f92672">&gt;</span> maxLeftSum <span style="color:#f92672">?</span> maxBorderSum <span style="color:#f92672">&gt;</span> maxRightSum <span style="color:#f92672">?</span> maxBorderSum : maxRightSum
</span></span><span style="display:flex;"><span>				: maxLeftSum <span style="color:#f92672">&gt;</span> maxRightSum <span style="color:#f92672">?</span> maxLeftSum : maxRightSum;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//int a[] = {-2, 11, -4, 13, -5, -2};
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> a[] <span style="color:#f92672">=</span> { <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">1</span> };
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> max <span style="color:#f92672">=</span> <span style="color:#a6e22e">maxSubSum</span>(a, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(a) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,max);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p>方法四：最优起点，扫描法</p>
<ul>
<li>算法思想：设 a[i] 为和最大序列的起点，则如果 a[i] 是负的，那么它不可能代表最优序列的起点，因为任何包含 a[i] 作为起点的子序列都可以通过 a[i+1] 作起点而得到改进。</li>
<li>类似的，任何负的子序列也不可能是最优子序列的前缀。</li>
<li>运行时间：O(N)</li>
</ul>
</li>
<li>
<p>C 语言版</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxSubSum</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> maxSum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">0</span>], i;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*考虑如果全是负数，那么返回最大的负数，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	如果最后的和为正，那么就使用扫描法*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(sum <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>){<span style="color:#75715e">//当前数小于0，换为下一个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			sum <span style="color:#f92672">=</span> a[i];
</span></span><span style="display:flex;"><span>		}<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>			sum <span style="color:#f92672">+=</span> a[i];
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(sum <span style="color:#f92672">&gt;</span> maxSum){
</span></span><span style="display:flex;"><span>			maxSum <span style="color:#f92672">=</span> sum;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> maxSum;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//int a[] = {-2, 11, -4, 13, -5, -2};
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> a[] <span style="color:#f92672">=</span> { <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">1</span> };
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(a) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>);<span style="color:#75715e">//有负数所以 strlen(a) 不能用 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> max <span style="color:#f92672">=</span> <span style="color:#a6e22e">maxSubSum</span>(a, len);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,max);	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="252-二分查找">
  2.5.2 二分查找
  <a class="anchor" href="#252-%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be">#</a>
</h4>
<blockquote>
<p>binary search 又叫对分查找、对半查找，时间复杂度 O(log N)</p>
</blockquote>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180631.png" alt="image-20200402152845271" /></p>
<p>【代码实现】</p>
<ul>
<li>C 语言版</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">binarySearch</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> low, mid, high;
</span></span><span style="display:flex;"><span>    low <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    high <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(low <span style="color:#f92672">&lt;=</span> high){
</span></span><span style="display:flex;"><span>    	mid <span style="color:#f92672">=</span> (low <span style="color:#f92672">+</span> high) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    	<span style="color:#66d9ef">if</span>(a[mid] <span style="color:#f92672">&lt;</span> x){
</span></span><span style="display:flex;"><span>    		low <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		}<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(a[mid] <span style="color:#f92672">&gt;</span> x){
</span></span><span style="display:flex;"><span>			high <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		}<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> mid;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a[] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span> };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(a) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>x);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">binarySearch</span>(a, len, x) <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Found %d.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,x);
</span></span><span style="display:flex;"><span>	}<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;NotFound %d.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,x);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="253-最大公约数">
  2.5.3 最大公约数
  <a class="anchor" href="#253-%e6%9c%80%e5%a4%a7%e5%85%ac%e7%ba%a6%e6%95%b0">#</a>
</h4>
<blockquote>
<p>又叫欧几里德算法 gcd(M, N)</p>
</blockquote>
<p>【代码实现】</p>
<ul>
<li>C 语言版：使用 while 循环</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">gcd</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> tmp;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span>(b <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>		tmp <span style="color:#f92672">=</span> a <span style="color:#f92672">%</span> b;
</span></span><span style="display:flex;"><span>		a <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>		b <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> a;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> x, y;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>x, <span style="color:#f92672">&amp;</span>y);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">gcd</span>(x, y));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>C 语言版：使用递归</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">gcd</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(b <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> a;
</span></span><span style="display:flex;"><span>	}<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">gcd</span>(b, a <span style="color:#f92672">%</span> b);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> x, y;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>x, <span style="color:#f92672">&amp;</span>y);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">gcd</span>(x, y));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="254-幂运算">
  2.5.4 幂运算
  <a class="anchor" href="#254-%e5%b9%82%e8%bf%90%e7%ae%97">#</a>
</h4>
<p>【题目】</p>
<p>求 x^n</p>
<p>【代码实现】</p>
<ul>
<li>C 语言版：递归</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pow</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> x;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(n <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pow</span>(x <span style="color:#f92672">*</span> x, n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>	}<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pow</span>(x <span style="color:#f92672">*</span> x, n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">*</span> x;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">pow</span>(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>));<span style="color:#75715e">//2^5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="第三章-线性表">
  第三章 线性表
  <a class="anchor" href="#%e7%ac%ac%e4%b8%89%e7%ab%a0-%e7%ba%bf%e6%80%a7%e8%a1%a8">#</a>
</h2>
<blockquote>
<p>线性表是具有相同类型的 n（n&gt;=0）个元素的有限序列，其中 n 为表长，当 n=0 时，该表为空表。</p>
</blockquote>
<p>线性表的特点：</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180636.png" alt="image-20200401205632451" /></p>
<p>一般线性表包含下列基本操作：</p>
<ul>
<li>初始化</li>
<li>销毁</li>
<li>重置为空表</li>
<li>判断是否为空</li>
<li>获取长度</li>
<li>根据位置获取对应元素</li>
<li>查找元素</li>
<li>获取指定元素的前驱和后继元素</li>
<li>插入元素</li>
<li>删除元素</li>
<li>遍历元素</li>
</ul>
<h3 id="31-抽象数据类型adt">
  3.1 抽象数据类型(ADT)
  <a class="anchor" href="#31-%e6%8a%bd%e8%b1%a1%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8badt">#</a>
</h3>
<pre tabindex="0"><code>ADT 线性表(SeqList)
Data
    线性表的数据对象集合为{a1,a2,....,an},每个元素的类型均为DataType。
    其中，除了第一个元素a1外，每一个元素有且只有一个直接前驱元素，除最后一个元素an外，
    每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。

Operation
    InitList(*L):初始化操作，建立一个空的线性表。
    ListEmpty(L):若线性表为空，返回true，否则返回false。
    ClearList(*L):线性表清空。
    GetElem(L,i,*e):将线性表L中第i个位置元素返回给e。
    LocateElem(L,e):在线性表L中查找与给定值e相等的元素，如果查找成功,返回该元素在表中的序列号；
    否则，返回0表示失败。
    InsertList(*L,i,e):在线性表的第i个位置插入元素e。
    DeleteList(*L,i,*e):删除线性表L中的第i个元素，并用e返回其值
    ListLength(L):返回线性表L的元素个数。
    PrintList(L):打印线性表
</code></pre><p>根据存储方式不同，线性表可以分为顺序表和链表：</p>
<ul>
<li>数据元素在内存中集中存储，采用顺序表示结构，简称 “顺序存储”；</li>
<li>数据元素在内存中分散存储，采用链式表示结构，简称 “链式存储”</li>
</ul>
<h3 id="32-顺序表">
  3.2 顺序表
  <a class="anchor" href="#32-%e9%a1%ba%e5%ba%8f%e8%a1%a8">#</a>
</h3>
<blockquote>
<p><strong>是指将线性表中的各个元素依次存放在一组地址连续的存储单元中，通常将这种方法存储的线性表称为顺序表</strong>。</p>
</blockquote>
<ul>
<li>线性表中第 i 个元素的存储位置与第一个元素的 a1 的存储位置满足以下关系，location(ai)  = location(a1) + (i-1) * m。其中，第一个元素的位置 location(a1) 称为起始地址或基地址。</li>
<li>顺序表逻辑上相邻的元素在物理上也是相邻的。每一个数据元素的存储位置都和线性表的起始位置相差一个和数据元素在线性表中的位序成正比的常数。只要确定了第一个元素的起始位置，线性表中的任一个元素都可以随机存取，因此，线性表的顺序存储结构是一种随机存取的存储结构。由于 C 语言的数组具有随机存储特别，因此采用数组来描述顺序表。</li>
<li>定义顺序表结构体：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>    DataType list[MaxSize];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> length;
</span></span><span style="display:flex;"><span>}SeqList;
</span></span></code></pre></div><p>其中，DataType 表示数据元素类型，list 用于存储线性表中的数据元素，length 用来表示线性表中数据元素的个数，SeqList 是结构体类型名。定义一个顺序表代码：SeqList L;  指向顺序表的指针：SeqList *L;</p>
<blockquote>
<p>顺序表的基本运算如下：</p>
</blockquote>
<p>（1）初始化线性表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitList</span>(SeqList <span style="color:#f92672">*</span>L){
</span></span><span style="display:flex;"><span>    L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; <span style="color:#75715e">//把线性表的长度设为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>（2）线性表非空判断</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ListEmpty</span>(SeqList <span style="color:#f92672">*</span>L){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（3）线性表清空</p>
<pre tabindex="0"><code>void ClearList(SeqList *L){//线性表清空。
	L-&gt;length =0; //把线性表的长度设为0
}
</code></pre><p>（4）按序号查找</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">GetElem</span>(SeqList <span style="color:#f92672">*</span>L, <span style="color:#66d9ef">int</span> i, DataType <span style="color:#f92672">*</span>e){
</span></span><span style="display:flex;"><span><span style="color:#75715e">//查找线性表中第i个元素，查找成功将该值返回给e，并返回1表示成功，反正返回-1表失败。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> i <span style="color:#f92672">&gt;</span> L<span style="color:#f92672">-&gt;</span>length){
</span></span><span style="display:flex;"><span>    	<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>e <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>list[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（5）按内容查找</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">LocateElem</span>(SeqList <span style="color:#f92672">*</span>L, DataType e){
</span></span><span style="display:flex;"><span><span style="color:#75715e">//查找线性表中元素值为e的元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> L<span style="color:#f92672">-&gt;</span>length ; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>list[i] <span style="color:#f92672">==</span> e){
</span></span><span style="display:flex;"><span>        	<span style="color:#66d9ef">return</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		}   
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//找不到返回0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>（6）插入操作</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//在顺序表的第i个位置插入元素e，成功返回1，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//失败返回-1，顺序表满了返回0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">InsertList</span>(SeqList <span style="color:#f92672">*</span>L, <span style="color:#66d9ef">int</span> i, DataType e){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> j;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> i <span style="color:#f92672">&gt;</span> L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">&gt;=</span> MaxSize){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(j <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>length; j <span style="color:#f92672">&gt;=</span> i; j<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>            L<span style="color:#f92672">-&gt;</span>list[j] <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>list[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        L<span style="color:#f92672">-&gt;</span>list[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span>e ;<span style="color:#75715e">//插入元素到i个位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（7）删除操作</p>
<p>觉得文章有帮助，不妨请我喝杯 Coffee，祝福好心人年年高升！</p>
<p>（8）返回线性表个数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ListLength</span>(SeqList <span style="color:#f92672">*</span>L){<span style="color:#75715e">//返回线性表L的元素个数。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> L<span style="color:#f92672">-&gt;</span>length;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（9）打印线性表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintList</span>(SeqList <span style="color:#f92672">*</span>L){<span style="color:#75715e">//打印线性表,即顺序表遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> L<span style="color:#f92672">-&gt;</span>length; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, L<span style="color:#f92672">-&gt;</span>list[i]);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><p>（10）主函数调用测试 main()</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){	
</span></span><span style="display:flex;"><span>	SeqList <span style="color:#f92672">*</span>L;
</span></span><span style="display:flex;"><span>	L <span style="color:#f92672">=</span> (SeqList <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(SeqList));<span style="color:#75715e">//申请内存空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//L-&gt;length = 10;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;初始化数组------</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//测试初始化数组长度为0 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">InitList</span>(L);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;插入节点------</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//测试插入数据元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">InsertList</span>(L, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">55</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">InsertList</span>(L, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">57</span>);	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">InsertList</span>(L, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">78</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">InsertList</span>(L, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">89</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//查看线性表是否为空 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">ListEmpty</span>(L) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;线性表为空</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); 
</span></span><span style="display:flex;"><span>	}<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;线性表不为空</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); 
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//测试 打印线性表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">PrintList</span>(L) ;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;删除节点------</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//删除测试
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">DeleteList</span>(L, <span style="color:#ae81ff">2</span>, p); 
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,<span style="color:#f92672">*</span>p);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;删除节点后------</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//测试 打印线性表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">PrintList</span>(L) ;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> <span style="color:#a6e22e">ListLength</span>(L);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;线性表长度为%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,l);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//查找元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//按内容查找 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">LocateElem</span>(L, <span style="color:#ae81ff">55</span>)){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;找到</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); 
</span></span><span style="display:flex;"><span>	} 
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//按序号查找 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">GetElem</span>(L, <span style="color:#ae81ff">2</span>, p);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,<span style="color:#f92672">*</span>p); 
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>提供另一种方式写顺序表，不申请内存空间 malloc</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MaxSize 100
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">//定义数据类型 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> DataType;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//线性数组 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    DataType list[MaxSize];
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//数组长度 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> length;
</span></span><span style="display:flex;"><span>}SeqList;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//初始化线性表 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitList</span>(SeqList <span style="color:#f92672">*</span>L){
</span></span><span style="display:flex;"><span>    L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; <span style="color:#75715e">//把线性表的长度设为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ListEmpty</span>(SeqList L){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(L.length <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ClearList</span>(SeqList <span style="color:#f92672">*</span>L){<span style="color:#75715e">//线性表清空。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; <span style="color:#75715e">//把线性表的长度设为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">GetElem</span>(SeqList L, <span style="color:#66d9ef">int</span> i, DataType <span style="color:#f92672">*</span>e){
</span></span><span style="display:flex;"><span><span style="color:#75715e">//查找线性表中第i个元素，查找成功将该值返回给e，并返回1表示成功，反正返回-1表失败。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> i <span style="color:#f92672">&gt;</span> L.length){
</span></span><span style="display:flex;"><span>    	<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>e <span style="color:#f92672">=</span> L.list[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">LocateElem</span>(SeqList L, DataType e){
</span></span><span style="display:flex;"><span><span style="color:#75715e">//查找线性表中元素值为e的元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> L.length ; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(L.list[i] <span style="color:#f92672">==</span> e){
</span></span><span style="display:flex;"><span>        	<span style="color:#66d9ef">return</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		}   
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//找不到返回0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//在顺序表的第i个位置插入元素e，成功返回1，失败返回-1，顺序表满了返回0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">InsertList</span>(SeqList <span style="color:#f92672">*</span>L, <span style="color:#66d9ef">int</span> i, DataType e){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> j;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> i <span style="color:#f92672">&gt;</span> L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">&gt;=</span> MaxSize){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(j <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>length; j <span style="color:#f92672">&gt;=</span> i; j<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>            L<span style="color:#f92672">-&gt;</span>list[j] <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>list[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        L<span style="color:#f92672">-&gt;</span>list[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span>e ;<span style="color:#75715e">//插入元素到i个位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">DeleteList</span>(SeqList <span style="color:#f92672">*</span>L, <span style="color:#66d9ef">int</span> i, DataType <span style="color:#f92672">*</span>e){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> j;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> i <span style="color:#f92672">&gt;</span> L<span style="color:#f92672">-&gt;</span>length){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>e <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>list[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(j <span style="color:#f92672">=</span> i;j <span style="color:#f92672">&lt;=</span> L<span style="color:#f92672">-&gt;</span>length<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            L<span style="color:#f92672">-&gt;</span>list[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>list[j];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ListLength</span>(SeqList L){<span style="color:#75715e">//返回线性表L的元素个数。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> L.length;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintList</span>(SeqList L){<span style="color:#75715e">//打印线性表,即顺序表遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> L.length; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, L.list[i]);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	SeqList L;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//L.length = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//L = (SeqList *)malloc(sizeof(SeqList));//申请内存空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//L-&gt;length = 10;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;初始化数组------</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//测试初始化数组长度为0 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">InitList</span>(<span style="color:#f92672">&amp;</span>L);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;插入节点------</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//测试插入数据元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">InsertList</span>(<span style="color:#f92672">&amp;</span>L, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">55</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">InsertList</span>(<span style="color:#f92672">&amp;</span>L, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">57</span>);	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">InsertList</span>(<span style="color:#f92672">&amp;</span>L, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">78</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">InsertList</span>(<span style="color:#f92672">&amp;</span>L, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">89</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//查看线性表是否为空 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">ListEmpty</span>(L) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;线性表为空</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); 
</span></span><span style="display:flex;"><span>	}<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;线性表不为空</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); 
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//测试 打印线性表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">PrintList</span>(L) ;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;删除节点------</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//删除测试
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">DeleteList</span>(<span style="color:#f92672">&amp;</span>L, <span style="color:#ae81ff">2</span>, p); 
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,<span style="color:#f92672">*</span>p);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;删除节点后------</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//测试 打印线性表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">PrintList</span>(L) ;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> <span style="color:#a6e22e">ListLength</span>(L);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;线性表长度为%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,l);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//查找元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//按内容查找 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">LocateElem</span>(L, <span style="color:#ae81ff">55</span>)){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;找到</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); 
</span></span><span style="display:flex;"><span>	} 
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//按序号查找 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">GetElem</span>(L, <span style="color:#ae81ff">2</span>, p);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,<span style="color:#f92672">*</span>p); 
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>!&gt; 小结：顺序表的优缺点。</p>
<p>（1）优点：无须关心表中元素之间的关系，所以不用增加额外的存储空间；可以快速地取表中任意位置的元素。</p>
<p>（2）缺点：插入和删除操作需要移动大量元素。使用前需事先分配好内存空间，当线性表长度变化较大时，难以确定存储空间的容量。分配空间过大会造成存储空间的巨大浪费，分配的空间过小，难以适应问题的需求</p>
<h3 id="33-链式表">
  3.3 链式表
  <a class="anchor" href="#33-%e9%93%be%e5%bc%8f%e8%a1%a8">#</a>
</h3>
<blockquote>
<p>链式表包括单链表、双链表、循环链表、循环单链表等等等</p>
</blockquote>
<h4 id="331-单链表">
  3.3.1 单链表
  <a class="anchor" href="#331-%e5%8d%95%e9%93%be%e8%a1%a8">#</a>
</h4>
<p>单链表的存储结构用C语言描述：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> DataType;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Node{
</span></span><span style="display:flex;"><span>    DataType data;<span style="color:#75715e">//创建数据域 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> Node <span style="color:#f92672">*</span>next;<span style="color:#75715e">//创建指针域 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}LinkList;
</span></span></code></pre></div><p>其中，LinkList 是链表的结点类型。</p>
<blockquote>
<p>单链表的基本运算如下：</p>
</blockquote>
<p>（1）初始化单链表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>LinkList <span style="color:#f92672">*</span> <span style="color:#a6e22e">InitList</span>(LinkList <span style="color:#f92672">*</span>p){
</span></span><span style="display:flex;"><span>	p <span style="color:#f92672">=</span> (LinkList <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(LinkList));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>p){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);<span style="color:#75715e">//exit函数，退出程序。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>!&gt; 真正使用的时候，直接在 CreateList 中定义即可，如下写法，根据实际需求使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>LinkList <span style="color:#f92672">*</span>q <span style="color:#f92672">=</span> (LinkList <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(LinkList));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>q){
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">exit</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>); <span style="color:#75715e">//exit函数，退出程序。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}	
</span></span><span style="display:flex;"><span>LinkList <span style="color:#f92672">*</span> r <span style="color:#f92672">=</span> q; <span style="color:#75715e">//创建尾指针指向尾节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>r<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span></code></pre></div><p>或者：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>LinkList <span style="color:#f92672">*</span>q <span style="color:#f92672">=</span> (LinkList <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(LinkList));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>q){
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">exit</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>); <span style="color:#75715e">//exit函数，退出程序。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}	
</span></span><span style="display:flex;"><span>q <span style="color:#f92672">=</span> NULL;
</span></span></code></pre></div><p>或者：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>LinkList <span style="color:#f92672">*</span>q <span style="color:#f92672">=</span> (LinkList <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(LinkList));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>q){
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">exit</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>); <span style="color:#75715e">//exit函数，退出程序。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}	
</span></span><span style="display:flex;"><span>q<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span></code></pre></div><p>（2）单链表非空判断</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ListEmpty</span>(LinkList <span style="color:#f92672">*</span>p){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>p){
</span></span><span style="display:flex;"><span>		flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> flag;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（3）按序号查询操作</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//按序号查找单链表中第i个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LinkList <span style="color:#f92672">*</span><span style="color:#a6e22e">GetElem</span>(LinkList <span style="color:#f92672">*</span>head,<span style="color:#66d9ef">int</span> i){
</span></span><span style="display:flex;"><span>    LinkList <span style="color:#f92672">*</span>p;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">ListEmpty</span>(head)<span style="color:#f92672">||</span>i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>){ <span style="color:#75715e">//如果链表为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span>NULL <span style="color:#f92672">&amp;&amp;</span> j<span style="color:#f92672">&lt;</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>){<span style="color:#75715e">//保证p的下个结点不为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(j<span style="color:#f92672">==</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#75715e">//找到第i个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（4）按内容查找操作</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//按内容查找单链表中元素值为e的元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">LocateElem</span>(LinkList <span style="color:#f92672">*</span>head,DataType e){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    LinkList <span style="color:#f92672">*</span>p;
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//指针p指向第一个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(p){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">!=</span> e){
</span></span><span style="display:flex;"><span>            p<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next;<span style="color:#75715e">//继续下一个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        	flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> flag;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（5）定位操作</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">LocatePos</span>(LinkList <span style="color:#f92672">*</span>head,DataType e){
</span></span><span style="display:flex;"><span>    LinkList <span style="color:#f92672">*</span>p;<span style="color:#75715e">//定义一个指向单链表的结点的指针p
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">ListEmpty</span>(head))<span style="color:#75715e">//非空判断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;<span style="color:#75715e">//指针p指向一个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    i <span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(p){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">==</span>e)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            p<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next;<span style="color:#75715e">//指向下一个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>p)<span style="color:#75715e">//如果没有找到与e相等的元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>         <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><p>（6）插入新数据元素 e 到 i 位置</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">InsertList</span>(LinkList <span style="color:#f92672">*</span>head,<span style="color:#66d9ef">int</span> i,DataType e){
</span></span><span style="display:flex;"><span>    LinkList <span style="color:#f92672">*</span>pre,<span style="color:#f92672">*</span>p;<span style="color:#75715e">//定义第i个元素的前驱结点指针pre，新生结点指针p
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    pre <span style="color:#f92672">=</span> head; <span style="color:#75715e">//指针pre指向头结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(pre<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;</span> i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>){ <span style="color:#75715e">//循环直到直到i元素前驱结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pre <span style="color:#f92672">=</span> pre<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(j <span style="color:#f92672">!=</span> i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#75715e">//如果没找到，插入位置出错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//新生一个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p <span style="color:#f92672">=</span> (LinkList <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(LinkList));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>p){
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span>e; <span style="color:#75715e">//将e赋值给结点的数据域
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> pre<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    pre<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span>p;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（7）删除第 i 个结点</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">DeleteList</span>(LinkList <span style="color:#f92672">*</span>head,<span style="color:#66d9ef">int</span> i,DataType <span style="color:#f92672">*</span>e){
</span></span><span style="display:flex;"><span>    LinkList <span style="color:#f92672">*</span>pre,<span style="color:#f92672">*</span>p;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    pre <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(pre<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">!=</span>NULL <span style="color:#f92672">&amp;&amp;</span> pre<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> j<span style="color:#f92672">&lt;</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        pre <span style="color:#f92672">=</span> pre<span style="color:#f92672">-&gt;</span>next;    
</span></span><span style="display:flex;"><span>        j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(j<span style="color:#f92672">!=</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//指针p指向单链表中的第i个结点,并将该结点数据域值赋值给e
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p <span style="color:#f92672">=</span> pre<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>e <span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>data;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//将前驱结点的指针域指向要删除结点的下一个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    pre<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(p);<span style="color:#75715e">//释放p指向的结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>; 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（8）打印单链表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintList</span>(LinkList <span style="color:#f92672">*</span> p){<span style="color:#75715e">//遍历输出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	LinkList <span style="color:#f92672">*</span>q;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">ListEmpty</span>(p)){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;链表为空！</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	}<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>		q <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//使指针指向下一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;链表中的数据为：</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (q){<span style="color:#75715e">//q!=NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">//printf(&#34;%d &#34;, q-&gt;data);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span>(q<span style="color:#f92672">-&gt;</span>next){
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d-&gt;&#34;</span>, q<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>			}<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, q<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			q <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（9）主函数调用测试 main()</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	LinkList <span style="color:#f92672">*</span>p; <span style="color:#75715e">//创建头指针，用来存放头结点的地址。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	p <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateList</span>(); <span style="color:#75715e">//CreateList()函数动态创建链表并返回头结点的地址。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">PrintList</span>(p); <span style="color:#75715e">//打印单链表数据 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">InsertList</span>(p, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">23</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">PrintList</span>(p); <span style="color:#75715e">//打印单链表数据 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">DeleteList</span>(p,<span style="color:#ae81ff">2</span>,<span style="color:#f92672">&amp;</span>x);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">PrintList</span>(p); <span style="color:#75715e">//打印单链表数据 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;删除 %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,x);
</span></span><span style="display:flex;"><span>    LinkList <span style="color:#f92672">*</span>q;
</span></span><span style="display:flex;"><span>	q <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetElem</span>(p,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;查找到%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,q<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">LocateElem</span>(p,<span style="color:#ae81ff">23</span>)<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;找到</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); 
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#a6e22e">LocatePos</span>(p,<span style="color:#ae81ff">23</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,i);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>简单的单链表创建输出数据：</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//定义数据类型 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> DataType;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Node{
</span></span><span style="display:flex;"><span>    DataType data;<span style="color:#75715e">//创建数据域 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> Node <span style="color:#f92672">*</span>next;<span style="color:#75715e">//创建指针域 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}LinkList;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LinkList <span style="color:#f92672">*</span> <span style="color:#a6e22e">CreateList</span>(){ 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//函数返回值为LinkList * 类型。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> len, i, x;
</span></span><span style="display:flex;"><span>	LinkList <span style="color:#f92672">*</span>q <span style="color:#f92672">=</span> (LinkList <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(LinkList));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>q){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;分配头结点空间失败，程序终止！</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exit</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>); <span style="color:#75715e">//exit函数，退出程序。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}	
</span></span><span style="display:flex;"><span>	LinkList <span style="color:#f92672">*</span> r <span style="color:#f92672">=</span> q; <span style="color:#75715e">//创建尾指针指向尾节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	r<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入链表的节点个数：len = &#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>len);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>len; <span style="color:#f92672">++</span>i){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入第%d个节点的值：&#34;</span>, i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>x);
</span></span><span style="display:flex;"><span>		LinkList <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> (LinkList <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(LinkList)); 
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//链表的不连续性在于它的内存空间在不断地一个个分配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>p){
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;分配空间失败，程序终止！</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">exit</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>		r<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>		r <span style="color:#f92672">=</span> p; <span style="color:#75715e">//递归
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> q;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintList</span>(LinkList <span style="color:#f92672">*</span> p){<span style="color:#75715e">//遍历输出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	LinkList <span style="color:#f92672">*</span>q;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">isEmpty</span>(p)){
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;链表为空！</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	}<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>		q <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//使指针指向下一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;链表中的数据为：</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (q){<span style="color:#75715e">//q!=NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d  &#34;</span>, q<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>			q <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">isEmpty</span>(LinkList <span style="color:#f92672">*</span>p){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>p){
</span></span><span style="display:flex;"><span>		flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> flag;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	LinkList <span style="color:#f92672">*</span> p; <span style="color:#75715e">//创建头指针，用来存放头结点的地址。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	p <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateList</span>(); <span style="color:#75715e">//CreateList()函数动态创建链表并返回头结点的地址。	
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">PrintList</span>(p); <span style="color:#75715e">//打印单链表数据 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="332-双链表">
  3.3.2 双链表
  <a class="anchor" href="#332-%e5%8f%8c%e9%93%be%e8%a1%a8">#</a>
</h4>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180649.png" alt="image-20200407164948729" /></p>
<h4 id="333-循环链表">
  3.3.3 循环链表
  <a class="anchor" href="#333-%e5%be%aa%e7%8e%af%e9%93%be%e8%a1%a8">#</a>
</h4>
<h5 id="3331-循环单链表">
  3.3.3.1 循环单链表
  <a class="anchor" href="#3331-%e5%be%aa%e7%8e%af%e5%8d%95%e9%93%be%e8%a1%a8">#</a>
</h5>
<blockquote>
<p>循环单链表（circular linkedlist）是首尾相连的一种单链表，即将最后一个结点的空指针改为指向头结点或第一个结点的形成一个环型，最后一个结点称为尾指针: rear。判断单链表为空的条件是 head-&gt;next == NULL，而判断循环单链表为空的条件是 head-&gt;next == head。访问第一个结点即 rear-&gt;next-&gt;next。</p>
</blockquote>
<p>如果将两个循环单链表（LA，LB）合成一个链表，只需将一个表的表尾和另一个表的表头连接即可。具体步骤为：</p>
<ul>
<li>将 LA-&gt;next = LB-&gt;next-&gt;next; 第一个结点。</li>
<li>释放 LB 的头结点，free(LB-&gt;next);</li>
<li>将 LB 的表尾与 LA 的表头相连，LB-&gt;next = LA-&gt;next。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>LinkList <span style="color:#f92672">*</span><span style="color:#a6e22e">Link</span>(LinkList <span style="color:#f92672">*</span>head1, LinkList <span style="color:#f92672">*</span>head2){
</span></span><span style="display:flex;"><span>    LinkList <span style="color:#f92672">*</span>p, <span style="color:#f92672">*</span>q;
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> head1;<span style="color:#75715e">//p指向1头结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> head1){<span style="color:#75715e">//循环使指针p指向链表的最后一个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    q <span style="color:#f92672">=</span> head2;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(q<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> head2){<span style="color:#75715e">//同上
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        q <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head2<span style="color:#f92672">-&gt;</span>next;<span style="color:#75715e">//将第一个链表的尾端连接第二个链表的第一个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    q<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head1; <span style="color:#75715e">// 将第二个链表的尾端连接到第一个连接的第一个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> head1;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>说明：也可以把循环单链表中的头结点成为哨兵结点。</p>
</blockquote>
<h5 id="3332-循环双链表">
  3.3.3.2 循环双链表
  <a class="anchor" href="#3332-%e5%be%aa%e7%8e%af%e5%8f%8c%e9%93%be%e8%a1%a8">#</a>
</h5>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180653.png" alt="image-20200407165318650" /></p>
<h2 id="第四章-栈和队列">
  第四章 栈和队列
  <a class="anchor" href="#%e7%ac%ac%e5%9b%9b%e7%ab%a0-%e6%a0%88%e5%92%8c%e9%98%9f%e5%88%97">#</a>
</h2>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180657.png" alt="" /></p>
<h3 id="41-栈">
  4.1 栈
  <a class="anchor" href="#41-%e6%a0%88">#</a>
</h3>
<blockquote>
<p>栈是只能在表尾进行插入或删除操作的线性表，通常我们称表尾端为栈顶，表头端为栈底，它是一种先进后出的线性表，既只能在表尾端插入元素，称为入栈，也只能在表尾端删除元素，称为退栈。栈有时又叫做 LIFO (后进先出) 表</p>
</blockquote>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180701.png" alt="" /></p>
<p>栈既然也是线性表，那么它也有顺序存储结构和链式存储结构两种表示方法，这两种表示方法实现类似。</p>
<p>通过栈可以解决很多问题，例如数值转换、括号匹配、迷宫求解、表达式求值和汉诺塔等等问题。</p>
<h4 id="411-栈的顺序存储">
  4.1.1 栈的顺序存储
  <a class="anchor" href="#411-%e6%a0%88%e7%9a%84%e9%a1%ba%e5%ba%8f%e5%ad%98%e5%82%a8">#</a>
</h4>
<h5 id="4111-存储结构">
  4.1.1.1 存储结构
  <a class="anchor" href="#4111-%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84">#</a>
</h5>
<blockquote>
<p>栈的存储结构用C语言描述：</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define TRUE 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define FALSE 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OK 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ERROR 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OVERFLOW -2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define INIT_SIZE 20
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define INCREMENT_SIZE 5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> SElemType;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 存储结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    SElemType <span style="color:#f92672">*</span>base;    <span style="color:#75715e">//栈尾指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    SElemType <span style="color:#f92672">*</span>top;        <span style="color:#75715e">//栈顶指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> size;            <span style="color:#75715e">//栈的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}SqStack;
</span></span></code></pre></div><h5 id="4112-基本运算">
  4.1.1.2 基本运算
  <a class="anchor" href="#4112-%e5%9f%ba%e6%9c%ac%e8%bf%90%e7%ae%97">#</a>
</h5>
<p>栈的基本运算如下：</p>
<p>（1）初始化栈</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 初始化栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">InitStack</span>(SqStack <span style="color:#f92672">*</span>S)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">=</span> (SElemType<span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(INIT_SIZE <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(SElemType));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>S<span style="color:#f92672">-&gt;</span>base)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(OVERFLOW);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> S<span style="color:#f92672">-&gt;</span>base;
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> INIT_SIZE;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（2）压栈</p>
<p>压栈的算法如下：</p>
<ul>
<li>(1) 判断是否栈满，若满则出错，需要重新分配空间</li>
<li>(2) 元素 e 压入栈顶</li>
<li>(3) 栈顶指针加 1</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 压栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">Push</span>(SqStack <span style="color:#f92672">*</span>S, SElemType e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((S<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">-</span> S<span style="color:#f92672">-&gt;</span>base) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(SElemType) <span style="color:#f92672">&gt;=</span> S<span style="color:#f92672">-&gt;</span>size)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        S<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">=</span> (SElemType<span style="color:#f92672">*</span>) <span style="color:#a6e22e">realloc</span>(S<span style="color:#f92672">-&gt;</span>base, (S<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">+</span> INCREMENT_SIZE) <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(SElemType));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>S<span style="color:#f92672">-&gt;</span>base)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">exit</span>(OVERFLOW);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        S<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> S<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">+</span> S<span style="color:#f92672">-&gt;</span>size;
</span></span><span style="display:flex;"><span>        S<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">+=</span> INCREMENT_SIZE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>S<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> e;
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">-&gt;</span>top<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（3）退栈</p>
<p>退栈的算法流程如下：</p>
<ul>
<li>(1) 判断是否栈空，若空则出错</li>
<li>(2) 获取栈顶元素 e</li>
<li>(3) 栈顶指针减 1</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 退栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">Pop</span>(SqStack <span style="color:#f92672">*</span>S, SElemType <span style="color:#f92672">*</span>e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (S<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">==</span> S<span style="color:#f92672">-&gt;</span>base)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ERROR;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">-&gt;</span>top<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>e <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>S<span style="color:#f92672">-&gt;</span>top;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（4）销毁栈</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 销毁栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">DestroyStack</span>(SqStack <span style="color:#f92672">*</span>S)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(S<span style="color:#f92672">-&gt;</span>base);
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（5）清空栈</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 清空栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">ClearStack</span>(SqStack <span style="color:#f92672">*</span>S)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> S<span style="color:#f92672">-&gt;</span>base;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（6）判空</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 判断栈是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">IsEmpty</span>(SqStack S)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (S.top <span style="color:#f92672">==</span> S.base)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（7）获取栈的长度</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 获取栈的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">GetLength</span>(SqStack S)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> S.top <span style="color:#f92672">-</span> S.base;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（8）获取栈顶元素</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 获取栈顶元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">GetTop</span>(SqStack S, SElemType <span style="color:#f92672">*</span>e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (S.top <span style="color:#f92672">&gt;</span> S.base)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>e <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">--</span>S.top);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ERROR;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（9）访问元素</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 访问元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">visit</span>(SElemType e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, e);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（10）遍历栈</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 遍历栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">TraverseStack</span>(SqStack S, <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>visit)(SElemType))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (S.top <span style="color:#f92672">&gt;</span> S.base)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">visit</span>(<span style="color:#f92672">*</span>S.base);
</span></span><span style="display:flex;"><span>        S.base<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（11）主函数测试</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    SqStack S;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">InitStack</span>(<span style="color:#f92672">&amp;</span>S))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        SElemType e;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;init_success</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">IsEmpty</span>(S))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Stack is empty</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Push</span>(<span style="color:#f92672">&amp;</span>S, i);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">GetTop</span>(S, <span style="color:#f92672">&amp;</span>e);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The first element is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, e);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;length is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLength</span>(S));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Pop</span>(<span style="color:#f92672">&amp;</span>S, <span style="color:#f92672">&amp;</span>e);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Pop element is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, e);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">TraverseStack</span>(S, <span style="color:#f92672">*</span>visit);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">DestroyStack</span>(<span style="color:#f92672">&amp;</span>S))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">destroy_success</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="4113-完整代码">
  4.1.1.3 完整代码
  <a class="anchor" href="#4113-%e5%ae%8c%e6%95%b4%e4%bb%a3%e7%a0%81">#</a>
</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define TRUE 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define FALSE 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OK 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ERROR 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OVERFLOW -2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define INIT_SIZE 20
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define INCREMENT_SIZE 5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> SElemType;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 存储结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    SElemType <span style="color:#f92672">*</span>base;    <span style="color:#75715e">//栈尾指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    SElemType <span style="color:#f92672">*</span>top;        <span style="color:#75715e">//栈顶指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> size;            <span style="color:#75715e">//栈的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}SqStack;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 初始化栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">InitStack</span>(SqStack <span style="color:#f92672">*</span>S)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">=</span> (SElemType<span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(INIT_SIZE <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(SElemType));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>S<span style="color:#f92672">-&gt;</span>base)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(OVERFLOW);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> S<span style="color:#f92672">-&gt;</span>base;
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> INIT_SIZE;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 销毁栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">DestroyStack</span>(SqStack <span style="color:#f92672">*</span>S)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(S<span style="color:#f92672">-&gt;</span>base);
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 清空栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">ClearStack</span>(SqStack <span style="color:#f92672">*</span>S)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> S<span style="color:#f92672">-&gt;</span>base;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 判断栈是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">IsEmpty</span>(SqStack S)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (S.top <span style="color:#f92672">==</span> S.base)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 获取栈的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">GetLength</span>(SqStack S)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> S.top <span style="color:#f92672">-</span> S.base;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 获取栈顶元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">GetTop</span>(SqStack S, SElemType <span style="color:#f92672">*</span>e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (S.top <span style="color:#f92672">&gt;</span> S.base)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>e <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">--</span>S.top);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ERROR;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 压栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">Push</span>(SqStack <span style="color:#f92672">*</span>S, SElemType e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((S<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">-</span> S<span style="color:#f92672">-&gt;</span>base) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(SElemType) <span style="color:#f92672">&gt;=</span> S<span style="color:#f92672">-&gt;</span>size)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        S<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">=</span> (SElemType<span style="color:#f92672">*</span>) <span style="color:#a6e22e">realloc</span>(S<span style="color:#f92672">-&gt;</span>base, (S<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">+</span> INCREMENT_SIZE) <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(SElemType));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>S<span style="color:#f92672">-&gt;</span>base)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">exit</span>(OVERFLOW);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        S<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> S<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">+</span> S<span style="color:#f92672">-&gt;</span>size;
</span></span><span style="display:flex;"><span>        S<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">+=</span> INCREMENT_SIZE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>S<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> e;
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">-&gt;</span>top<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 退栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">Pop</span>(SqStack <span style="color:#f92672">*</span>S, SElemType <span style="color:#f92672">*</span>e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (S<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">==</span> S<span style="color:#f92672">-&gt;</span>base)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ERROR;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">-&gt;</span>top<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>e <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>S<span style="color:#f92672">-&gt;</span>top;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 访问元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">visit</span>(SElemType e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, e);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 遍历栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">TraverseStack</span>(SqStack S, <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>visit)(SElemType))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (S.top <span style="color:#f92672">&gt;</span> S.base)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">visit</span>(<span style="color:#f92672">*</span>S.base);
</span></span><span style="display:flex;"><span>        S.base<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    SqStack S;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">InitStack</span>(<span style="color:#f92672">&amp;</span>S))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        SElemType e;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;init_success</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">IsEmpty</span>(S))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Stack is empty</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Push</span>(<span style="color:#f92672">&amp;</span>S, i);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">GetTop</span>(S, <span style="color:#f92672">&amp;</span>e);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The first element is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, e);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;length is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLength</span>(S));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Pop</span>(<span style="color:#f92672">&amp;</span>S, <span style="color:#f92672">&amp;</span>e);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Pop element is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, e);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">TraverseStack</span>(S, <span style="color:#f92672">*</span>visit);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">DestroyStack</span>(<span style="color:#f92672">&amp;</span>S))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">destroy_success</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="42-队列">
  4.2 队列
  <a class="anchor" href="#42-%e9%98%9f%e5%88%97">#</a>
</h3>
<blockquote>
<p>队列是一种先进先出的线性表，只能在一端插入元素，在另一端删除元素，如下图所示，允许插入元素的一端称为队尾，允许删除元素的一端称为队头。</p>
</blockquote>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180712.png" alt="" /></p>
<p>队列也一样有顺序和链式存储结构两种表示方法。</p>
<h4 id="421-队列的链式存储">
  4.2.1 队列的链式存储
  <a class="anchor" href="#421-%e9%98%9f%e5%88%97%e7%9a%84%e9%93%be%e5%bc%8f%e5%ad%98%e5%82%a8">#</a>
</h4>
<h5 id="4211-存储结构">
  4.2.1.1 存储结构
  <a class="anchor" href="#4211-%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84">#</a>
</h5>
<p>队列的存储结构用C语言描述：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define TRUE 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define FALSE 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OK 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ERROR 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OVERFLOW -2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> QElemType;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 存储结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> QNode
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    QElemType data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> QNode <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>}QNode, <span style="color:#f92672">*</span>QueuePtr;
</span></span></code></pre></div><h5 id="4212-基本运算">
  4.2.1.2 基本运算
  <a class="anchor" href="#4212-%e5%9f%ba%e6%9c%ac%e8%bf%90%e7%ae%97">#</a>
</h5>
<p>队列的基本运算如下：</p>
<p>（1）初始化队列</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 初始化队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">InitQueue</span>(LinkQueue <span style="color:#f92672">*</span>Q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Q<span style="color:#f92672">-&gt;</span>front <span style="color:#f92672">=</span> Q<span style="color:#f92672">-&gt;</span>rear <span style="color:#f92672">=</span> (QueuePtr) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(QNode));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>Q<span style="color:#f92672">-&gt;</span>front)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(OVERFLOW);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Q<span style="color:#f92672">-&gt;</span>front<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（2）销毁队列</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 销毁队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">DestroyQueue</span>(LinkQueue <span style="color:#f92672">*</span>Q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (Q<span style="color:#f92672">-&gt;</span>front)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Q<span style="color:#f92672">-&gt;</span>rear <span style="color:#f92672">=</span> Q<span style="color:#f92672">-&gt;</span>front<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(Q<span style="color:#f92672">-&gt;</span>front);
</span></span><span style="display:flex;"><span>        Q<span style="color:#f92672">-&gt;</span>front <span style="color:#f92672">=</span> Q<span style="color:#f92672">-&gt;</span>rear;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（3）清空队列</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 清空队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">ClearQueue</span>(LinkQueue <span style="color:#f92672">*</span>Q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">DestroyQueue</span>(Q);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">InitQueue</span>(Q);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（4）判空</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 判断队列是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">IsEmpty</span>(LinkQueue Q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Q.front<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（5）获取队列的长度</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 获取队列的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">GetLength</span>(LinkQueue Q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    QueuePtr p <span style="color:#f92672">=</span> Q.front;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (Q.rear <span style="color:#f92672">!=</span> p)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> i;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（6）获取队头元素</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 获取队头元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">GetHead</span>(LinkQueue Q, QElemType <span style="color:#f92672">*</span>e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    QueuePtr p;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Q.front <span style="color:#f92672">==</span> Q.rear)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ERROR;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> Q.front<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>e <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（7）入队</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 入队
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">EnQueue</span>(LinkQueue <span style="color:#f92672">*</span>Q, QElemType e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    QueuePtr p <span style="color:#f92672">=</span> (QueuePtr) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(QNode));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>p)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(OVERFLOW);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> e;
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    Q<span style="color:#f92672">-&gt;</span>rear<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>    Q<span style="color:#f92672">-&gt;</span>rear <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（8）出队</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 出队
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">DeQueue</span>(LinkQueue <span style="color:#f92672">*</span>Q, QElemType <span style="color:#f92672">*</span>e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    QueuePtr p;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Q<span style="color:#f92672">-&gt;</span>front <span style="color:#f92672">==</span> Q<span style="color:#f92672">-&gt;</span>rear)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ERROR;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> Q<span style="color:#f92672">-&gt;</span>front<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>e <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>data;
</span></span><span style="display:flex;"><span>    Q<span style="color:#f92672">-&gt;</span>front<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Q<span style="color:#f92672">-&gt;</span>rear <span style="color:#f92672">==</span> p)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Q<span style="color:#f92672">-&gt;</span>rear <span style="color:#f92672">=</span> Q<span style="color:#f92672">-&gt;</span>front;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(p);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（9）访问元素</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 访问元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">visit</span>(QElemType e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, e);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（10）遍历队列</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 遍历队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">TraverseQueue</span>(LinkQueue Q, <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>visit)(QElemType))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    QueuePtr p <span style="color:#f92672">=</span> Q.front<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (p)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">visit</span>(p<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（11）主函数测试</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    LinkQueue Q;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">InitQueue</span>(<span style="color:#f92672">&amp;</span>Q))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        QElemType e;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;init_success</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">IsEmpty</span>(Q))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;queue is empty</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">EnQueue</span>(<span style="color:#f92672">&amp;</span>Q, i);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">GetHead</span>(Q, <span style="color:#f92672">&amp;</span>e);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The first element is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, e);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;length is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLength</span>(Q));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">DeQueue</span>(<span style="color:#f92672">&amp;</span>Q, <span style="color:#f92672">&amp;</span>e);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;delete element is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, e);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">TraverseQueue</span>(Q, <span style="color:#f92672">*</span>visit);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">DestroyQueue</span>(<span style="color:#f92672">&amp;</span>Q))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">destroy_success</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="4213-完整代码">
  4.2.1.3 完整代码
  <a class="anchor" href="#4213-%e5%ae%8c%e6%95%b4%e4%bb%a3%e7%a0%81">#</a>
</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define TRUE 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define FALSE 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OK 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ERROR 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OVERFLOW -2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> QElemType;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 存储结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> QNode
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    QElemType data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> QNode <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>}QNode, <span style="color:#f92672">*</span>QueuePtr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    QueuePtr front;    <span style="color:#75715e">//队头指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    QueuePtr rear;    <span style="color:#75715e">//队尾指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}LinkQueue;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 初始化队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">InitQueue</span>(LinkQueue <span style="color:#f92672">*</span>Q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Q<span style="color:#f92672">-&gt;</span>front <span style="color:#f92672">=</span> Q<span style="color:#f92672">-&gt;</span>rear <span style="color:#f92672">=</span> (QueuePtr) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(QNode));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>Q<span style="color:#f92672">-&gt;</span>front)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(OVERFLOW);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Q<span style="color:#f92672">-&gt;</span>front<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 销毁队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">DestroyQueue</span>(LinkQueue <span style="color:#f92672">*</span>Q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (Q<span style="color:#f92672">-&gt;</span>front)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Q<span style="color:#f92672">-&gt;</span>rear <span style="color:#f92672">=</span> Q<span style="color:#f92672">-&gt;</span>front<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">free</span>(Q<span style="color:#f92672">-&gt;</span>front);
</span></span><span style="display:flex;"><span>        Q<span style="color:#f92672">-&gt;</span>front <span style="color:#f92672">=</span> Q<span style="color:#f92672">-&gt;</span>rear;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 清空队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">ClearQueue</span>(LinkQueue <span style="color:#f92672">*</span>Q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">DestroyQueue</span>(Q);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">InitQueue</span>(Q);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 判断队列是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">IsEmpty</span>(LinkQueue Q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Q.front<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 获取队列的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">GetLength</span>(LinkQueue Q)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    QueuePtr p <span style="color:#f92672">=</span> Q.front;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (Q.rear <span style="color:#f92672">!=</span> p)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> i;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 获取队头元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">GetHead</span>(LinkQueue Q, QElemType <span style="color:#f92672">*</span>e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    QueuePtr p;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Q.front <span style="color:#f92672">==</span> Q.rear)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ERROR;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> Q.front<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>e <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 入队
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">EnQueue</span>(LinkQueue <span style="color:#f92672">*</span>Q, QElemType e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    QueuePtr p <span style="color:#f92672">=</span> (QueuePtr) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(QNode));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>p)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(OVERFLOW);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> e;
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    Q<span style="color:#f92672">-&gt;</span>rear<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>    Q<span style="color:#f92672">-&gt;</span>rear <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 出队
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">DeQueue</span>(LinkQueue <span style="color:#f92672">*</span>Q, QElemType <span style="color:#f92672">*</span>e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    QueuePtr p;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Q<span style="color:#f92672">-&gt;</span>front <span style="color:#f92672">==</span> Q<span style="color:#f92672">-&gt;</span>rear)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ERROR;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> Q<span style="color:#f92672">-&gt;</span>front<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>e <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>data;
</span></span><span style="display:flex;"><span>    Q<span style="color:#f92672">-&gt;</span>front<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Q<span style="color:#f92672">-&gt;</span>rear <span style="color:#f92672">==</span> p)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Q<span style="color:#f92672">-&gt;</span>rear <span style="color:#f92672">=</span> Q<span style="color:#f92672">-&gt;</span>front;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(p);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 访问元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">visit</span>(QElemType e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, e);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 遍历队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>Status <span style="color:#a6e22e">TraverseQueue</span>(LinkQueue Q, <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>visit)(QElemType))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    QueuePtr p <span style="color:#f92672">=</span> Q.front<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (p)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">visit</span>(p<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> OK;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    LinkQueue Q;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">InitQueue</span>(<span style="color:#f92672">&amp;</span>Q))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        QElemType e;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;init_success</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">IsEmpty</span>(Q))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;queue is empty</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">EnQueue</span>(<span style="color:#f92672">&amp;</span>Q, i);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">GetHead</span>(Q, <span style="color:#f92672">&amp;</span>e);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The first element is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, e);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;length is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLength</span>(Q));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">DeQueue</span>(<span style="color:#f92672">&amp;</span>Q, <span style="color:#f92672">&amp;</span>e);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;delete element is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, e);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">TraverseQueue</span>(Q, <span style="color:#f92672">*</span>visit);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">DestroyQueue</span>(<span style="color:#f92672">&amp;</span>Q))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">destroy_success</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="第五章-树">
  第五章 树
  <a class="anchor" href="#%e7%ac%ac%e4%ba%94%e7%ab%a0-%e6%a0%91">#</a>
</h2>
<h3 id="基本概念">
  基本概念
  <a class="anchor" href="#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5">#</a>
</h3>
<p><strong>n个结点，有n-1个边</strong></p>
<p>树中一个结点的子结点的个数称为该<strong>结点的度</strong></p>
<p>树种最大度数称为<strong>树的度</strong></p>
<p>度大于0的结点为<strong>分支结点</strong></p>
<p>度为0的结点为<strong>叶子结点</strong></p>
<p>有序树与无序树</p>
<p><strong>路径</strong>：树中两个结点之间的路径，且一定是自上而下的。</p>
<p><strong>路径长度</strong>：路径上所经历边的个数</p>
<p><strong>森林</strong>：m课互不相交的树的集合</p>
<h3 id="树的性质">
  树的性质
  <a class="anchor" href="#%e6%a0%91%e7%9a%84%e6%80%a7%e8%b4%a8">#</a>
</h3>
<ol>
<li>树中的结点数等于所有结点的度数加1</li>
<li>度为m的树中第i层上至多有$m^{i-1}$个结点($i \ge 1$)</li>
<li>高度为h的m叉树至多有$(m^b-1)/(m-1)$个结点</li>
<li>具有n个结点的m叉树的最小高度为$log_m[n(m-1)+1]$</li>
</ol>
<h3 id="二叉树定义">
  二叉树定义
  <a class="anchor" href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e5%ae%9a%e4%b9%89">#</a>
</h3>
<p><strong>二叉树</strong>：每个结点最多有2个子结点</p>
<p>度为2的有序树：每个结点最多有2个子结点 且 必须有一个结点具有2个子结点</p>
<p>二叉树可以为空，而度为2的有序树至少有三个结点。</p>
<p>二叉树的孩子结点始终有左右之分，而度为2的有序树的孩子结点次序是相对的。</p>
<hr>
<p><strong>满二叉树</strong>：一棵高度为h，且含有$2^h-1$个结点的二叉树为满二叉树。对于编号为i的结点，若存在，其双亲编号为[i/2]，左孩子为2i，右孩子为2i+1。</p>
<p><img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200323232543.png" alt="" /></p>
<hr>
<p><strong>完全二叉树</strong>：设一个高度为h，有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号1~n的结点一一对应时，称为完全二叉树。</p>
<p>性质：</p>
<ol>
<li>若$i \le [n/2]$，则结点i为分支结点，否则为叶子结点。</li>
<li>叶子结点只可能在层次最大的两层出现。对于最大层次的叶子接待你，都依次排列在最左边的位置上。</li>
<li>度为1的结点若存在，则可能有一个，且是编号最大的分支结点，并且孩子结点一定是左节点。</li>
</ol>
<p><img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200323233011.png" alt="" /></p>
<hr>
<p><strong>二叉排序树</strong>：一棵二叉树，若树非空则具有如下性质：对于任意结点若存在左子树或右子树，则其左子树上所有结点的关键字均小于该结点，右子树上所有结点的关键字均大于该结点。</p>
<p><img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200323233230.png" alt="" /></p>
<hr>
<p><strong>平衡二叉树</strong>：树上任意结点的左子树和右子树的深度之差不超过1。</p>
<p><img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200323233341.png" alt="" /></p>
<h3 id="二叉树性质">
  二叉树性质
  <a class="anchor" href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e6%80%a7%e8%b4%a8">#</a>
</h3>
<ol>
<li>
<p>非空二叉树上的叶子结点数等于度为2的结点数加1，即$n_0=n_2+1$</p>
<p>如何推导：</p>
<p>$①. n=n_0+n_1+n_2$ 结点总数=$\sum\limits_{i=0}^{2}$度为i的结点数</p>
<p>$②. n=n_1+2n_2+1$ 结点总数= 边数+1 = $\sum\limits_{i=0}^{2}$度为i的结点数*该结点的出度i</p>
</li>
<li>
<p>非空二叉树上第k层上至多有$2^{k-1}$个结点($k \ge 1$)</p>
</li>
<li>
<p>高度为h的二叉树至多有$2^h-1$个结点($h \ge 1$)</p>
</li>
<li>
<p>结点i所在层次为$[log_2i]+1$</p>
</li>
<li>
<p>具有n个($n \ge 1$)结点的完全二叉树的高度为$[log_2n]+1$ (由4得)或$[log_2(n+1)]$ (由3得)</p>
</li>
</ol>
<h3 id="二叉树存储">
  二叉树存储
  <a class="anchor" href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e5%ad%98%e5%82%a8">#</a>
</h3>
<p><strong>顺序存储</strong>：用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素。</p>
<ul>
<li>
<p>适合完全二叉树。</p>
</li>
<li>
<p>最坏情况下会非常浪费存储空间。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>ElementType tree[MAXSIZE] <span style="color:#f92672">=</span> {};
</span></span></code></pre></div><p><strong>链式存储</strong>：用链表来存放二叉树，二叉树中每个结点用链表的一个链结点来存储。</p>
<ul>
<li>含有n个结点的二叉链表，有n+1个空链域。</li>
<li>2n-(n-1) = n+1</li>
<li>2n表示总链域数，n个结点，每个结点有两个指针域</li>
<li>n-1表示非空链域，每个链域指向一个孩子结点，所以n-1个孩子结点就有n-1个非空链域。除了根节点，每个结点都能作为孩子结点，所以是n-1个孩子结点。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Node {
</span></span><span style="display:flex;"><span>	ElementType data;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> Node <span style="color:#f92672">*</span>lchild, <span style="color:#f92672">*</span>rchild;
</span></span><span style="display:flex;"><span>} Node, <span style="color:#f92672">*</span>BiTree;
</span></span></code></pre></div><h3 id="二叉树遍历">
  二叉树遍历
  <a class="anchor" href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e9%81%8d%e5%8e%86">#</a>
</h3>
<p>先序遍历：根，左子树，右子树</p>
<p>中序遍历：左子树，根，右子树</p>
<p>后序遍历：左子树，右子树，根</p>
<p>层次遍历：从左至右，从上至下</p>
<p>递归实现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PreOrder</span>(BiTree T) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (T <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">visit</span>(T);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">PreOrder</span>(T<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">PreOrder</span>(T<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InOrder</span>(BiTree T) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (T <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">InOrder</span>(T<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">visit</span>(T);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">InOrder</span>(T<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PostOrder</span>(BiTree T) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (T <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">PostOrder</span>(T<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">PostOrder</span>(T<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">visit</span>(T);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>中序遍历非递归实现</strong></p>
<ol>
<li>初始时依次扫描根节点的所有左侧结点并将他们一一入栈；</li>
<li>出栈一个结点，访问它；</li>
<li>扫描该结点的右孩子结点并将其入栈；</li>
<li>依次扫描右孩子结点的所有左侧结点并一一入栈；</li>
<li>反复该过程直到栈空为止。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InOrderTraverse</span>(BiTree T) {
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>S;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">InitStack</span>(S);
</span></span><span style="display:flex;"><span>    BiTree p <span style="color:#f92672">=</span> T;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (p <span style="color:#f92672">||</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">IsEmpty</span>(S)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (p) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Push</span>(S, p);
</span></span><span style="display:flex;"><span>            p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Pop</span>(S, p); <span style="color:#a6e22e">visit</span>(p);
</span></span><span style="display:flex;"><span>            p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PreOrderTraverse</span>(BiTree T) {
</span></span><span style="display:flex;"><span>    Node <span style="color:#f92672">*</span>S;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">InitStack</span>(S);
</span></span><span style="display:flex;"><span>    BiTree p <span style="color:#f92672">=</span> T;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Push</span>(S, p);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (p <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">||</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">IsEmpty</span>(S)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Pop</span>(S, p);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">visit</span>(p);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Push</span>(S, p<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">Push</span>(S, p<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>后序遍历非递归实现</strong></p>
<p>待定。</p>
<p><strong>层次遍历</strong></p>
<ol>
<li>初始时将根入队并访问根节点</li>
<li>若有左子树，则将左子树的根入队</li>
<li>若有右子树，则将右子树的根入队</li>
<li>然后出队，访问该结点</li>
<li>反复该过程直到队列为空</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">levelOrder</span>(BiTree T) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">InitQueue</span>(Q);
</span></span><span style="display:flex;"><span>    BiTree p;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">EnQueue</span>(Q, T);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">isEmpty</span>(Q)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">DeQueue</span>(Q, p);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">visit</span>(p);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">EnQueue</span>(Q, p<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">EnQueue</span>(Q, p<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="遍历序列构造二叉树">
  遍历序列构造二叉树
  <a class="anchor" href="#%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91">#</a>
</h3>
<p>先（后）序遍历序列和中序遍历序列可以确定一棵二叉树。</p>
<p>而后序遍历序列和先序遍历序列不可以确定一棵二叉树。</p>
<h3 id="线索二叉树">
  线索二叉树
  <a class="anchor" href="#%e7%ba%bf%e7%b4%a2%e4%ba%8c%e5%8f%89%e6%a0%91">#</a>
</h3>
<p>线索化：</p>
<ul>
<li>若无左子树，则将左指针指向其前驱结点；</li>
<li>若无右子树，则将右指针指向其后继结点。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> ThreadNode {
</span></span><span style="display:flex;"><span>	ElementType data;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> Node <span style="color:#f92672">*</span>lchild, <span style="color:#f92672">*</span>rchild;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ltag, rtag;
</span></span><span style="display:flex;"><span>} ThreadNode, <span style="color:#f92672">*</span>ThreadTree;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// l(r)tag :
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 0: l(r)child域指向的是孩子结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 1: l(r)child域指向的是前驱(后继)结点
</span></span></span></code></pre></div><p>中序线索二叉树寻找对应结点的前驱与后继更加方便。我们主要研究中序线索二叉树。</p>
<p><img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200329152739.png" alt="" /></p>
<p><strong>中序线索二叉树</strong></p>
<ul>
<li>前驱结点
<ul>
<li>若左指针为线索，则其指向的结点为前驱结点</li>
<li>若左指针为左孩子，则其左子树的最右侧结点为前驱结点</li>
</ul>
</li>
<li>后继结点
<ul>
<li>若右指针为线索，则其指向的结点为后继结点</li>
<li>若右指针为右孩子，则其右子树的最左侧结点为后继结点</li>
</ul>
</li>
</ul>
<p><strong>中序线索二叉树的线索化实现</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InThread</span>(ThreadTree <span style="color:#f92672">&amp;</span>p, ThreadTree <span style="color:#f92672">&amp;</span>pre) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">InThread</span>(p<span style="color:#f92672">-&gt;</span>lchild, pre);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">=</span> pre;
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">-&gt;</span>ltag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pre <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> pre<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        pre<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>        pre<span style="color:#f92672">-&gt;</span>rtag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    pre <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">InThread</span>(p<span style="color:#f92672">-&gt;</span>rchild, pre);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>得到的中序线索二叉树：</p>
<p><img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200329154148.png" alt="" /></p>
<p>还可以将剩余两个指针利用起来，指向一个头节点的前驱与后继。</p>
<p><img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200329154206.png" alt="" /></p>
<p><strong>中序线索二叉树遍历</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 找到中序遍历的第一个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ThreadNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">FirstNode</span>(ThreadNode <span style="color:#f92672">*</span>p) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (p<span style="color:#f92672">-&gt;</span>ltag <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 找下一个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ThreadNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">NextNode</span>(ThreadNode <span style="color:#f92672">*</span>p) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>rtag <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#75715e">// 如果右指针是孩子结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">FirstNode</span>(p<span style="color:#f92672">-&gt;</span>rchild); <span style="color:#75715e">// 找右孩子的左子树中第一个结点，为我们要的后继结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span> <span style="color:#75715e">// 如果右指针是线索
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> p<span style="color:#f92672">-&gt;</span>rchild; <span style="color:#75715e">// rchild就是我们要的后继结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 中序线索树的遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InOrder</span>(ThreadNode <span style="color:#f92672">*</span>T) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (ThreadNode <span style="color:#f92672">*</span>p<span style="color:#f92672">=</span><span style="color:#a6e22e">FirstNode</span>(T); p <span style="color:#f92672">!=</span> NULL; p <span style="color:#f92672">=</span> <span style="color:#a6e22e">NextNode</span>(p)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">visit</span>(p);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="树的存储">
  树的存储
  <a class="anchor" href="#%e6%a0%91%e7%9a%84%e5%ad%98%e5%82%a8">#</a>
</h3>
<ul>
<li>
<p>双亲表示法</p>
<p>采用一组连续的存储空间来存储每个结点，同时在每个节点中增设一个伪指针，指示双亲结点在数组中的位置。根结点的下标为0，其伪指针域为-1。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    ElemType data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> parent;
</span></span><span style="display:flex;"><span>} PTNode;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    PTNode nodes[MAX_TREE_SIZE];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>} PTree;
</span></span></code></pre></div><p><img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200329172140.png" alt="" /></p>
</li>
<li>
<p>孩子表示法</p>
<p>将每个结点的孩子结点都用单链表连接起来形成一个线性结构，n个结点具有n个孩子链表。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 孩子结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> child; <span style="color:#75715e">// 孩子结点的下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> CNode <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>} CNode;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    ElemType data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> CNode <span style="color:#f92672">*</span>child;
</span></span><span style="display:flex;"><span>} PNode;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    PNode nodes[MAX_TREE_SIZE];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>} CTree;
</span></span></code></pre></div><p><img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200329172614.png" alt="" /></p>
</li>
<li>
<p>孩子兄弟表示法</p>
<p>以二叉链表作为树的存储结构，又称二叉树表示法。</p>
<p>左孩子，右兄弟</p>
<p><img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200329172759.png" alt="" /></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> strct CSNode {
</span></span><span style="display:flex;"><span>    ElemType data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> CSNode <span style="color:#f92672">*</span>firstchild, <span style="color:#f92672">*</span>nextsibling;
</span></span><span style="display:flex;"><span>} CSNode, CSTree;
</span></span></code></pre></div><p><img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200329172930.png" alt="" /></p>
</li>
</ul>
<p><strong>优缺点比较</strong></p>
<table>
  <thead>
      <tr>
          <th></th>
          <th>优点</th>
          <th>缺点</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>双亲表示法</td>
          <td>寻找结点的双亲结点效率高</td>
          <td>寻找结点的孩子结点效率低</td>
      </tr>
      <tr>
          <td>孩子表示法</td>
          <td>寻找结点的孩子结点效率高</td>
          <td>寻找结点的双亲结点效率低</td>
      </tr>
      <tr>
          <td>孩子兄弟表示法</td>
          <td>寻找结点的孩子结点效率高，方便实现树转换成二叉树</td>
          <td>寻找结点的双亲结点效率低</td>
      </tr>
  </tbody>
</table>
<h3 id="树森林与二叉树的转换">
  树、森林与二叉树的转换
  <a class="anchor" href="#%e6%a0%91%e6%a3%ae%e6%9e%97%e4%b8%8e%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e8%bd%ac%e6%8d%a2">#</a>
</h3>
<p><strong>树与二叉树的转换</strong></p>
<p>规则：每个结点左指针指向它的第一个孩子结点，右指针指向它在树中的相邻兄弟结点。</p>
<p><strong>森林与二叉树的转换</strong></p>
<p>规则：将每一棵树转换为二叉树，将每棵二叉树的根依次作为上一棵二叉树的右子树。</p>
<p>转换是唯一的</p>
<h3 id="树的遍历">
  树的遍历
  <a class="anchor" href="#%e6%a0%91%e7%9a%84%e9%81%8d%e5%8e%86">#</a>
</h3>
<ul>
<li>
<p>先根遍历</p>
<p>若树非空，先访问根节点，再按从左至右的顺序遍历根节点的每棵子树。</p>
</li>
<li>
<p>后根遍历</p>
<p>若树非空，则先按从左到右的顺序遍历根节点的每棵子树，再访问根节点。</p>
</li>
<li>
<p>层次遍历</p>
</li>
</ul>
<p>⭐树的先根遍历序列与这棵树对应二叉树的先序遍历序列相同。</p>
<p>⭐树的后根遍历序列与这棵树对应二叉树的<strong>中序</strong>遍历序列相同。</p>
<h3 id="森林的遍历">
  森林的遍历
  <a class="anchor" href="#%e6%a3%ae%e6%9e%97%e7%9a%84%e9%81%8d%e5%8e%86">#</a>
</h3>
<ul>
<li>
<p>先序遍历</p>
<p>若森林非空，则，</p>
<ul>
<li>
<p>访问森林中第一棵树的根节点</p>
</li>
<li>
<p>先序遍历第一棵树的子树森林</p>
</li>
<li>
<p>先序遍历除去第一棵树之后的剩余的树构成的森林</p>
</li>
</ul>
</li>
<li>
<p>中序遍历</p>
<p>若森林非空，则，</p>
<ul>
<li>中序遍历第一棵树的根节点的子树森林</li>
<li>访问第一棵树的根节点</li>
<li>中序遍历除去第一棵树之后剩余的树构成的子树森林</li>
</ul>
</li>
</ul>
<p>⭐森林的先序遍历序列与森林对应二叉树的先序遍历序列相同。</p>
<p>⭐森林的中序遍历序列与森林对应二叉树的中序遍历序列相同。</p>
<h3 id="遍历序列的对应关系">
  遍历序列的对应关系
  <a class="anchor" href="#%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e7%9a%84%e5%af%b9%e5%ba%94%e5%85%b3%e7%b3%bb">#</a>
</h3>
<p><img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200329181130.png" alt="" /></p>
<h3 id="树的应用-并查集">
  树的应用-并查集
  <a class="anchor" href="#%e6%a0%91%e7%9a%84%e5%ba%94%e7%94%a8-%e5%b9%b6%e6%9f%a5%e9%9b%86">#</a>
</h3>
<p>并查集是一种简单的集合表示。</p>
<p>通常用树的<strong>双亲表示法</strong>作为并查集的存储结构。</p>
<p>定义以下几个方法：</p>
<ul>
<li>
<p>Initial(S) 将集合S中的每个元素都初始化为只有一个单元素的子集合</p>
</li>
<li>
<p>Union(S, Root1, Root2)</p>
<p>把集合S中的子集合（互不相交）Root2并入子集合Root1</p>
</li>
<li>
<p>Find(S, X)</p>
<p>查找集合S中单元素x所在子集合，并返回该子集合的名字。</p>
</li>
</ul>
<p><img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200329182810.png" alt="" /></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> UFSets[SIZE];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Initial</span>(<span style="color:#66d9ef">int</span> S[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> size; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        s[i] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Find</span>(<span style="color:#66d9ef">int</span> S[], <span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(S[x] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> S[x];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Union</span>(<span style="color:#66d9ef">int</span> S[], <span style="color:#66d9ef">int</span> Root1, <span style="color:#66d9ef">int</span> Root2) {
</span></span><span style="display:flex;"><span>    S[Root1] <span style="color:#f92672">+=</span> S[Root2]; <span style="color:#75715e">//更新Root1的根节点值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    S[Root2] <span style="color:#f92672">=</span> Root1; <span style="color:#75715e">//更新Root2的根节点值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="树的应用-二叉排序树">
  树的应用-二叉排序树
  <a class="anchor" href="#%e6%a0%91%e7%9a%84%e5%ba%94%e7%94%a8-%e4%ba%8c%e5%8f%89%e6%8e%92%e5%ba%8f%e6%a0%91">#</a>
</h3>
<p>BST，也称二叉查找树。</p>
<p>二叉排序树或者为空树，或者为非空树，当为非空树时有如下特点：</p>
<ol>
<li>
<p>若左子树非空，则左子树上所有结点关键字均<strong>小于</strong>根节点的关键字。</p>
</li>
<li>
<p>若右子树非空，则右子树上所有结点关键字均<strong>大于</strong>根节点的关键字。</p>
</li>
<li>
<p>左右子树本身也分别是一棵二叉排序树。</p>
</li>
</ol>
<p>⭐中序遍历二叉排序树，得到的是一个递增的有序序列。</p>
<p><strong>查找</strong></p>
<p>二叉树非空时，查找根节点，若相等则查找成功；</p>
<p>若不等，则当小于根节点值时，查找左子树；当大于根节点值时，查找右子树。</p>
<p>当查找到叶节点仍没查找到相应的值，则查找失败。</p>
<p><strong>非递归算法实现查找算法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>BSTNode <span style="color:#f92672">*</span><span style="color:#a6e22e">BST_Search</span>(BiTree T, ElemType key, BSTNode <span style="color:#f92672">*&amp;</span>p) {
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (T<span style="color:#f92672">!=</span>NULL <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">!=</span>T<span style="color:#f92672">-&gt;</span>data) {
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> T;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">&lt;</span> T<span style="color:#f92672">-&gt;</span>data)
</span></span><span style="display:flex;"><span>            T<span style="color:#f92672">=</span>T<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            T<span style="color:#f92672">=</span>T<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> T;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>插入操作</strong></p>
<p>若二叉排序树为空，则直接插入结点；</p>
<p>若二叉排序树非空，</p>
<p>​	当值小于根节点时，插入左子树；</p>
<p>​	当值大于根节点时，插入右子树；</p>
<p>​	当值等于根节点时，不进行插入；</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">BST_Insert</span>(BiTree <span style="color:#f92672">&amp;</span>T, KeyType k) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (T <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        T <span style="color:#f92672">=</span> (BiTree)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(BSTNode));
</span></span><span style="display:flex;"><span>        T<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">=</span> k;
</span></span><span style="display:flex;"><span>        T<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">=</span> T<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (k <span style="color:#f92672">==</span> T<span style="color:#f92672">-&gt;</span>key)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (k <span style="color:#f92672">&lt;</span> T<span style="color:#f92672">-&gt;</span>key)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">BST_Insert</span>(T<span style="color:#f92672">-&gt;</span>lchild, k);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">BST_Insert</span>(T<span style="color:#f92672">-&gt;</span>rchild, k);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>构造二叉排序树</strong></p>
<p>不断调用插入函数来构造。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Create_BST</span>(BiTree <span style="color:#f92672">&amp;</span>T, KeyType str[], <span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>    T <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> n) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">BST_Insert</span>(T, str[i]);
</span></span><span style="display:flex;"><span>        i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>删除操作</strong></p>
<p>若被删结点是叶子结点，则可以直接删除。</p>
<p>若被删结点z只有一棵子树，则让z的子树成为z父结点的子树，代替z结点。</p>
<p>若被删除结点z有两棵子树，则让z的中序序列直接后继代替z，并删去直接后继结点。</p>
<p>在二叉排序树中删除并插入某个结点，得到的二叉排序树不一定相同。</p>
<p><strong>查找效率</strong></p>
<p>平均查找长度ASL取决于树的高度。</p>
<p><img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200329202122.png" alt="" /></p>
<h2 id="第六章-散列">
  第六章 散列
  <a class="anchor" href="#%e7%ac%ac%e5%85%ad%e7%ab%a0-%e6%95%a3%e5%88%97">#</a>
</h2>
<h2 id="第七章-优先队列堆">
  第七章 优先队列（堆）
  <a class="anchor" href="#%e7%ac%ac%e4%b8%83%e7%ab%a0-%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97%e5%a0%86">#</a>
</h2>
<h2 id="第八章-排序">
  第八章 排序
  <a class="anchor" href="#%e7%ac%ac%e5%85%ab%e7%ab%a0-%e6%8e%92%e5%ba%8f">#</a>
</h2>
<h3 id="81--排序算法简述">
  8.1  排序算法简述
  <a class="anchor" href="#81--%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e7%ae%80%e8%bf%b0">#</a>
</h3>
<blockquote>
<p>理解：</p>
</blockquote>
<ul>
<li>
<p>排序的目的：快速查找</p>
</li>
<li>
<p>衡量排序算法的优劣</p>
<ul>
<li>时间复杂度：分析关键字的比较次数和记录的移动次数。</li>
<li>空间复杂度：分析排序算法中需要多少辅助内存。</li>
<li>稳定性：若两个记录 A 和 B 的关键字相等，但排序后 A 和 B 的先后次序保持不变，则称这种排序算法是稳定的。</li>
</ul>
</li>
<li>
<p>排序的分类</p>
<ul>
<li>内部排序
<ul>
<li>选择排序
<ul>
<li>直接选择排序、堆排序</li>
</ul>
</li>
<li>交换排序
<ul>
<li>冒泡排序、快速排序</li>
</ul>
</li>
<li>插入排序
<ul>
<li>直接插入排序、折半插入排序、Shell 排序</li>
</ul>
</li>
<li>归并排序</li>
<li>桶式排序</li>
<li>基数排序</li>
</ul>
</li>
<li>外部排序（需要借助于磁盘）
<ul>
<li>多路归并排序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="82-插入排序">
  8.2 插入排序
  <a class="anchor" href="#82-%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f">#</a>
</h3>
<h4 id="821-直接插入排序">
  8.2.1 直接插入排序
  <a class="anchor" href="#821-%e7%9b%b4%e6%8e%a5%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f">#</a>
</h4>
<h5 id="8211-算法思想">
  8.2.1.1 算法思想
  <a class="anchor" href="#8211-%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3">#</a>
</h5>
<p>做法是：每次从无序表中取出第一个元素，把它插入到有序表的合适位置，使有序表仍然有序。</p>
<ul>
<li>（1）第一趟比较前两个数，然后把第二个数按大小插入到有序表中；</li>
<li>（2）第二趟把第三个数据与前两个数从前向后扫描，把第三个数按大小插入到有序表中；</li>
<li>（3）依次进行下去，进行了(n-1)趟扫描以后就完成了整个排序过程。</li>
</ul>
<p>如下图所示。</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180754.gif" alt="" /></p>
<h5 id="8212-算法步骤">
  8.2.1.2 算法步骤
  <a class="anchor" href="#8212-%e7%ae%97%e6%b3%95%e6%ad%a5%e9%aa%a4">#</a>
</h5>
<p>算法步骤：</p>
<ul>
<li>（1）判断是否需要进行调整，如果 <code>array[i] &lt; array[i-1]</code> 就需要进行；如果不需要调整，直接判断下一个数是否要调整。</li>
<li>（2）使用 <code>array[0]</code> 暂存需要调整的数</li>
<li>（3）在 <code>array[1..i-1]</code> 中查找 <code>aray[i]</code> 的插入位置，<code>array[1..j] &lt; array[i] &lt; R[j+1..i-1]</code>；将 <code>array[j+1..i-1]</code>中的所有记录均后移一个位置；</li>
<li>（4）将 <code>array[0]</code> 插入到 <code>array[j+1]</code> 的位置上。</li>
</ul>
<h5 id="8213-算法实现">
  8.2.1.3 算法实现
  <a class="anchor" href="#8213-%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0">#</a>
</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InsertSort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i, j;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 判断是否需要调整
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (array[i] <span style="color:#f92672">&lt;</span> array[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 使用 array[0] 保存 array[i]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            array[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> array[i];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 记录后移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            array[i] <span style="color:#f92672">=</span> array[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>; array[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> array[j]; j<span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                array[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> array[j];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 插入到有序子数组中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            array[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> array[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="8214-完整代码">
  8.2.1.4 完整代码
  <a class="anchor" href="#8214-%e5%ae%8c%e6%95%b4%e4%bb%a3%e7%a0%81">#</a>
</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 直接插入排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InsertSort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i, j;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (array[i] <span style="color:#f92672">&lt;</span> array[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            array[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> array[i];
</span></span><span style="display:flex;"><span>            array[i] <span style="color:#f92672">=</span> array[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>; array[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> array[j]; j<span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                array[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> array[j];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            array[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> array[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入数组的大小：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
</span></span><span style="display:flex;"><span>    array <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span> (n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入数据（用空格分隔）：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>array[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">InsertSort</span>(array);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;排序后为：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, array[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="822-希尔排序">
  8.2.2 希尔排序
  <a class="anchor" href="#822-%e5%b8%8c%e5%b0%94%e6%8e%92%e5%ba%8f">#</a>
</h4>
<h5 id="8221-算法思想">
  8.2.2.1 算法思想
  <a class="anchor" href="#8221-%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3">#</a>
</h5>
<p>希尔排序也是插入排序的一种，但它在效率上要比上面的直接插入排序高，它是对直接插入排序的改进，它的基本思想是：</p>
<ul>
<li>（1）先取一个小于 n 的整数 d1 作为第一个增量，把文件的全部记录分组。</li>
<li>（2）所有距离为 d1 的倍数的记录放在同一个组中。先在各组内进行直接插入排序；</li>
<li>（3）然后，取第二个增量 d2&lt; d1 重复上述的分组和排序，直至所取的增量 dt=1(dt&lt;&hellip;&lt; d2&lt; d1)，即所有记录放在同一组中进行直接插入排序为止。</li>
</ul>
<p>增量序列尤为关键（如何选择最佳增量序列，目前尚未解决），一般的初次取序列的一半为增量，以后每次减半，直到增量为 1。</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180801.png" alt="image-20200414113433980" /></p>
<h5 id="8222-算法步骤">
  8.2.2.2 算法步骤
  <a class="anchor" href="#8222-%e7%ae%97%e6%b3%95%e6%ad%a5%e9%aa%a4">#</a>
</h5>
<p>算法步骤：</p>
<ul>
<li>（1）选择一个增量序列：初始 <code>k = n / 2</code>、之后 <code>k = k / 2</code>，仅作举例；</li>
<li>（2）当 k &gt; 0 时进行排序，会进行多趟排序；</li>
<li>（3）每趟排序，根据对应的增量 k，将待排序列分割成若干子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h5 id="8223-算法实现">
  8.2.2.3 算法实现
  <a class="anchor" href="#8223-%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0">#</a>
</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ShellSort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e">//增量序列（仅作举例）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (k <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i, j;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 划分子序列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 插入排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (array[i] <span style="color:#f92672">&lt;</span> array[i <span style="color:#f92672">-</span> k])
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                array[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> array[i];
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> k; j <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> array[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> array[j]; j <span style="color:#f92672">-=</span> k)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    array[j <span style="color:#f92672">+</span> k] <span style="color:#f92672">=</span> array[j];
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                array[j <span style="color:#f92672">+</span> k] <span style="color:#f92672">=</span> array[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 重新赋值 k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        k <span style="color:#f92672">=</span> k <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="8224-完整代码">
  8.2.2.4 完整代码
  <a class="anchor" href="#8224-%e5%ae%8c%e6%95%b4%e4%bb%a3%e7%a0%81">#</a>
</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 希尔排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ShellSort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e">//增量序列（仅作举例）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (k <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i, j;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span>n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (array[i] <span style="color:#f92672">&lt;</span> array[i <span style="color:#f92672">-</span> k])
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                array[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> array[i];
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> k; j <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> array[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> array[j]; j <span style="color:#f92672">-=</span> k)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    array[j <span style="color:#f92672">+</span> k] <span style="color:#f92672">=</span> array[j];
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                array[j <span style="color:#f92672">+</span> k] <span style="color:#f92672">=</span> array[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        k <span style="color:#f92672">=</span> k <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入数组的大小：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
</span></span><span style="display:flex;"><span>    array <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span> (n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入数据（用空格分隔）：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>array[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ShellSort</span>(array);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;排序后为：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, array[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="83-交换排序">
  8.3 交换排序
  <a class="anchor" href="#83-%e4%ba%a4%e6%8d%a2%e6%8e%92%e5%ba%8f">#</a>
</h3>
<h4 id="831-冒泡排序">
  8.3.1 冒泡排序
  <a class="anchor" href="#831-%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f">#</a>
</h4>
<h5 id="8311-算法思想">
  8.3.1.1 算法思想
  <a class="anchor" href="#8311-%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3">#</a>
</h5>
<p>冒泡排序是一种交换排序，它的主要过程是：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。比较一趟之后，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180806.gif" alt="" /></p>
<h5 id="8312-算法步骤">
  8.3.1.2 算法步骤
  <a class="anchor" href="#8312-%e7%ae%97%e6%b3%95%e6%ad%a5%e9%aa%a4">#</a>
</h5>
<p>算法步骤：</p>
<ul>
<li>（1）外层循环定义进行 n-1 趟排序</li>
<li>（2）内层循环进行两两比较</li>
<li>（3）如果左边元素 <code>array[j]</code> 大于右侧元素 <code>array[j + 1]</code>，则进行交换</li>
</ul>
<h5 id="8313-算法实现">
  8.3.1.3 算法实现
  <a class="anchor" href="#8313-%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0">#</a>
</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">BubbleSort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i, j, temp;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> i; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 交换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (array[j] <span style="color:#f92672">&gt;</span> array[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                temp <span style="color:#f92672">=</span> array[j];
</span></span><span style="display:flex;"><span>                array[j] <span style="color:#f92672">=</span> array[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>                array[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="8314-完整代码">
  8.3.1.4 完整代码
  <a class="anchor" href="#8314-%e5%ae%8c%e6%95%b4%e4%bb%a3%e7%a0%81">#</a>
</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 冒泡排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">BubbleSort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i, j, temp;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> i; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (array[j] <span style="color:#f92672">&gt;</span> array[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                temp <span style="color:#f92672">=</span> array[j];
</span></span><span style="display:flex;"><span>                array[j] <span style="color:#f92672">=</span> array[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>                array[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入数组的大小：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
</span></span><span style="display:flex;"><span>    array <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span> n);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入数据（用空格分隔）：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>array[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">BubbleSort</span>(array);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;排序后为：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, array[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="832-快速排序">
  8.3.2 快速排序
  <a class="anchor" href="#832-%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f">#</a>
</h4>
<h5 id="8321-算法思想">
  8.3.2.1 算法思想
  <a class="anchor" href="#8321-%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3">#</a>
</h5>
<p>快速排序是对冒泡排序的改进，它的基本思想是通过一趟排序将数据分成两部分，一部分中的数据都比另一部分中的数据小，再对这两部分中的数据再排序，直到整个序列有序。</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180811.gif" alt="" /></p>
<h5 id="8322-算法步骤">
  8.3.2.2 算法步骤
  <a class="anchor" href="#8322-%e7%ae%97%e6%b3%95%e6%ad%a5%e9%aa%a4">#</a>
</h5>
<p>其实现非常简单：</p>
<ul>
<li>（1）使用 <code>Partition</code> 函数从原始数组中选取一个元素为中心。</li>
<li>（1）所有比它小的元素一律前放，比它大的元素一律后放，形成左右两个子表，这里递归调用本身分别将两个子表进行排序（对各子表重新选择中心元素并依此规则调整，直到每个子表的元素只剩一个，此时 high &gt;= low，递归结束）</li>
</ul>
<h5 id="8323-算法实现">
  8.3.2.3 算法实现
  <a class="anchor" href="#8323-%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0">#</a>
</h5>
<ul>
<li>实现的关键是分割原始数组：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Partition</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array, <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> pivotkey <span style="color:#f92672">=</span> array[low];
</span></span><span style="display:flex;"><span>    array[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> array[low];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;</span> high)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;</span> high <span style="color:#f92672">&amp;&amp;</span> array[high] <span style="color:#f92672">&gt;=</span> pivotkey)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            high<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        array[low] <span style="color:#f92672">=</span> array[high];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;</span> high <span style="color:#f92672">&amp;&amp;</span> array[low] <span style="color:#f92672">&lt;=</span> pivotkey)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            low<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        array[high] <span style="color:#f92672">=</span> array[low];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    array[low] <span style="color:#f92672">=</span> array[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> low;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>快速排序</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">QuickSort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array, <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (low <span style="color:#f92672">&lt;</span> high)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> pivotloc <span style="color:#f92672">=</span> <span style="color:#a6e22e">Partition</span>(array, low, high);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">QuickSort</span>(array, low, pivotloc <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">QuickSort</span>(array, pivotloc <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, high);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="8324-完整代码">
  8.3.2.4 完整代码
  <a class="anchor" href="#8324-%e5%ae%8c%e6%95%b4%e4%bb%a3%e7%a0%81">#</a>
</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 分割使枢轴记录的左边元素比右边元素小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Partition</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array, <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> pivotkey <span style="color:#f92672">=</span> array[low];
</span></span><span style="display:flex;"><span>    array[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> array[low];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;</span> high)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;</span> high <span style="color:#f92672">&amp;&amp;</span> array[high] <span style="color:#f92672">&gt;=</span> pivotkey)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            high<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        array[low] <span style="color:#f92672">=</span> array[high];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;</span> high <span style="color:#f92672">&amp;&amp;</span> array[low] <span style="color:#f92672">&lt;=</span> pivotkey)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            low<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        array[high] <span style="color:#f92672">=</span> array[low];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    array[low] <span style="color:#f92672">=</span> array[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> low;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 快速排序递归实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">QuickSort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array, <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (low <span style="color:#f92672">&lt;</span> high)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> pivotloc <span style="color:#f92672">=</span> <span style="color:#a6e22e">Partition</span>(array, low, high);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">QuickSort</span>(array, low, pivotloc <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">QuickSort</span>(array, pivotloc <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, high);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入数组的大小：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
</span></span><span style="display:flex;"><span>    array <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span> (n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入数据（用空格分隔）：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>array[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">QuickSort</span>(array, <span style="color:#ae81ff">1</span>, n);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;排序后为：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, array[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="84-选择排序">
  8.4 选择排序
  <a class="anchor" href="#84-%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f">#</a>
</h3>
<h4 id="841-简单选择排序">
  8.4.1 简单选择排序
  <a class="anchor" href="#841-%e7%ae%80%e5%8d%95%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f">#</a>
</h4>
<h5 id="8411-算法思想">
  8.4.1.1 算法思想
  <a class="anchor" href="#8411-%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3">#</a>
</h5>
<p>简单选择排序的基本思想是：</p>
<p>通过 n-1 次数据元素的比较，从 n-i+1 个记录中选择最小的数据，并与第 i 个数据进行交换，如下图所示。</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180817.png" alt="image-20200414114918938" /></p>
<h5 id="8412-算法步骤">
  8.4.1.2 算法步骤
  <a class="anchor" href="#8412-%e7%ae%97%e6%b3%95%e6%ad%a5%e9%aa%a4">#</a>
</h5>
<p>算法步骤：</p>
<ul>
<li>（1）循环 n 次，进行 n 趟排序</li>
<li>（2）在第 i 趟排序中，从第 i 个元素开始向后查找最小的元素</li>
<li>（3）将这个最小的元素不是第 i 个，而是在 i 之后的元素，则将这两个元素的位置对换。</li>
</ul>
<h5 id="8413-算法实现">
  8.4.1.3 算法实现
  <a class="anchor" href="#8413-%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0">#</a>
</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SelectSort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i, j, k, temp;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// n 趟排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        k <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 寻找最小的元素下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (array[j] <span style="color:#f92672">&lt;</span> array[k])
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                k <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果这个不是第 i 个，则交换第 i 个和第 k 个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (k <span style="color:#f92672">!=</span> i)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            temp <span style="color:#f92672">=</span> array[i];
</span></span><span style="display:flex;"><span>            array[i] <span style="color:#f92672">=</span> array[k];
</span></span><span style="display:flex;"><span>            array[k] <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="8414-完整代码">
  8.4.1.4 完整代码
  <a class="anchor" href="#8414-%e5%ae%8c%e6%95%b4%e4%bb%a3%e7%a0%81">#</a>
</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 选择排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SelectSort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i, j, k, temp;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        k <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (array[j] <span style="color:#f92672">&lt;</span> array[k])
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                k <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (k <span style="color:#f92672">!=</span> i)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            temp <span style="color:#f92672">=</span> array[i];
</span></span><span style="display:flex;"><span>            array[i] <span style="color:#f92672">=</span> array[k];
</span></span><span style="display:flex;"><span>            array[k] <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入数组的大小：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
</span></span><span style="display:flex;"><span>    array <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span> n);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入数据（用空格分隔）：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>array[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">SelectSort</span>(array);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;排序后为：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, array[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="842-堆排序">
  8.4.2 堆排序
  <a class="anchor" href="#842-%e5%a0%86%e6%8e%92%e5%ba%8f">#</a>
</h4>
<h5 id="8421-算法思想">
  8.4.2.1 算法思想
  <a class="anchor" href="#8421-%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3">#</a>
</h5>
<p>通过前面二叉树的学习，我们知道堆是完全二叉树，有最大堆和最小堆，其中最大堆是父结点的值比子结点大，相应的最小堆就是父结点的值比子节点小。</p>
<p>堆排序就是利用了最大堆（或最小堆）堆顶记录的关键字最大（或最小）这一特征，使得在当前无序区中选取最大（或最小）关键字变得简单。以最大堆为例，它的基本思想就是：</p>
<ol>
<li>先将初始文件 <code>R[1..n]</code> 建成一个最大堆，此堆为初始的无序区；</li>
<li>再将关键字最大的记录 <code>R[1]</code>（即堆顶）和无序区的最后一个记录 <code>R[n</code>] 交换，由此得到新的无序区 <code>R[1..n-1]</code> 和有序区 <code>R[n]</code>，且满足 <code>R[1..n-1].keys≤R[n].key</code>；</li>
<li>由于交换后新的根 <code>R[1]</code> 可能违反堆性质，故应将当前无序区 <code>R[1..n-1]</code> 调整为堆。然后再次将 <code>R[1..n-1]</code> 中关键字最大的记录 <code>R[1]</code> 和该区间的最后一个记录 <code>R[n-1]</code> 交换，由此得到新的无序区 <code>R[1..n-2]</code> 和有序区 <code>R[n-1..n</code>]，且仍满足关系 <code>R[1..n-2].keys≤R[n1..n].keys</code>，同样要将 <code>R[1..n-2]</code> 调整为堆；</li>
<li>重复此操作直到全部有序。</li>
</ol>
<p>下面是示例图：</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180823.png" alt="image-20200414115223369" /></p>
<h5 id="8422-算法实现">
  8.4.2.2 算法实现
  <a class="anchor" href="#8422-%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0">#</a>
</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 生成堆
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">HeapAdjust</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array, <span style="color:#66d9ef">int</span> s, <span style="color:#66d9ef">int</span> m)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    array[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> array[s];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> s <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;=</span> m; i <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> m <span style="color:#f92672">&amp;&amp;</span> array[i] <span style="color:#f92672">&lt;</span> array[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(array[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> array[i]))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        array[s] <span style="color:#f92672">=</span> array[i];
</span></span><span style="display:flex;"><span>        s <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    array[s] <span style="color:#f92672">=</span> array[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 堆排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">HeapSort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">HeapAdjust</span>(array, i, n);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> n; i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        array[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> array[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        array[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> array[i];
</span></span><span style="display:flex;"><span>        array[i] <span style="color:#f92672">=</span> array[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">HeapAdjust</span>(array, <span style="color:#ae81ff">1</span>, i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入数组的大小：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
</span></span><span style="display:flex;"><span>    array <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span> (n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入数据（用空格分隔）：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>array[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">HeapSort</span>(array);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;排序后为：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, array[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="85-归并排序">
  8.5 归并排序
  <a class="anchor" href="#85-%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f">#</a>
</h3>
<h4 id="851-算法思想">
  8.5.1 算法思想
  <a class="anchor" href="#851-%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3">#</a>
</h4>
<p>归并排序是建立在归并操作上的一种有效的排序算法，它过程为：</p>
<blockquote>
<p>比较 a[i] 和 a[j] 的大小，若 a[i]≤a[j]，则将第一个有序表中的元素 a[i] 复制到 r[k] 中，并令 i 和 k 分别加上 1；</p>
<p>否则将第二个有序表中的元素 a[j] 复制到 r[k] 中，并令 j 和 k 分别加上 1；</p>
<p>如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到 r 中从下标 k 到下标 t 的单元。</p>
</blockquote>
<p>如下图所示。</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180830.gif" alt="" /></p>
<h4 id="852-算法实现">
  8.5.2 算法实现
  <a class="anchor" href="#852-%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 合并
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Merge</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>source, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>target, <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> m, <span style="color:#66d9ef">int</span> n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> j, k;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> m <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, k <span style="color:#f92672">=</span> i; i <span style="color:#f92672">&lt;=</span> m <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;=</span> n; k<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (source[i] <span style="color:#f92672">&lt;=</span> source[j])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            target[k] <span style="color:#f92672">=</span> source[i<span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            target[k] <span style="color:#f92672">=</span> source[j<span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;=</span> m)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        target[k<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> source[i<span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&lt;=</span> n)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        target[k<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> source[j<span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 归并排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MergeSort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>source, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>target, <span style="color:#66d9ef">int</span> s, <span style="color:#66d9ef">int</span> t)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">int</span> m, <span style="color:#f92672">*</span>temp;
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">if</span> (s <span style="color:#f92672">==</span> t)
</span></span><span style="display:flex;"><span>     {
</span></span><span style="display:flex;"><span>         target[s] <span style="color:#f92672">=</span> source[s];
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>     {
</span></span><span style="display:flex;"><span>         temp <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span> (t <span style="color:#f92672">-</span> s <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>         m <span style="color:#f92672">=</span> (s <span style="color:#f92672">+</span> t) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>         <span style="color:#a6e22e">MergeSort</span>(source, temp, s, m);
</span></span><span style="display:flex;"><span>         <span style="color:#a6e22e">MergeSort</span>(source, temp, m <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, t);
</span></span><span style="display:flex;"><span>         <span style="color:#a6e22e">Merge</span>(temp, target, s, m, t);
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入数组的大小：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
</span></span><span style="display:flex;"><span>    array <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span> n);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入数据（用空格分隔）：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>array[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MergeSort</span>(array, array, <span style="color:#ae81ff">0</span>, n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;排序后为：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, array[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><h3 id="86-基数排序">
  8.6 基数排序
  <a class="anchor" href="#86-%e5%9f%ba%e6%95%b0%e6%8e%92%e5%ba%8f">#</a>
</h3>
<h4 id="861-算法思想">
  8.6.1 算法思想
  <a class="anchor" href="#861-%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3">#</a>
</h4>
<p>基数排序是跟前面的几种排序算法完全不一样的排序算法，前面的排序算法主要通过关键字之间的比较和移动来实现，而基数排序不需要进行关键字之间的比较，它是借助多关键字的思想来实现的对于数字，每一位上的数字就是一个关键字，每一位的数字范围就是关键字范围，它的主要过程为：</p>
<blockquote>
<p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零；</p>
<p>然后，从最低位开始，依次进行一次排序；</p>
<p>这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。</p>
</blockquote>
<p>如下图所示。类似从低位到高位比较，就是从次关键字到主关键字比较，这种称为最低位优先（LSD），反之称为最高位优先（MSD）。</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180835.gif" alt="" /></p>
<h5 id="862-算法实现">
  8.6.2 算法实现
  <a class="anchor" href="#862-%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0">#</a>
</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;    <span style="color:#75715e">//元素个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> bit_num;    <span style="color:#75715e">//最大数字位数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 获取相应位置上的数（从右到左）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">GetNumInPos</span>(<span style="color:#66d9ef">int</span> num, <span style="color:#66d9ef">int</span> pos)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i, temp <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> pos <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        temp <span style="color:#f92672">*=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (num <span style="color:#f92672">/</span> temp) <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 基数排序（LSD）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">RadixSort</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> radix <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>count, <span style="color:#f92672">*</span>bucket, i, j, k;
</span></span><span style="display:flex;"><span>    count <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span> radix);
</span></span><span style="display:flex;"><span>    bucket <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span> n);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (k <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; k <span style="color:#f92672">&lt;=</span> bit_num; k<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> radix; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            count[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//统计各个桶中所盛数据个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            count[<span style="color:#a6e22e">GetNumInPos</span>(array[i], k)]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//count[i]表示第i个桶的右边界索引
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> radix; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            count[i] <span style="color:#f92672">=</span> count[i] <span style="color:#f92672">+</span> count[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//分配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            j <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetNumInPos</span>(array[i], k);
</span></span><span style="display:flex;"><span>            bucket[count[j] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> array[i];
</span></span><span style="display:flex;"><span>            count[j]<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//收集
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>, j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            array[i] <span style="color:#f92672">=</span> bucket[j];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入最大数字的位数：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>bit_num);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入数组的大小：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
</span></span><span style="display:flex;"><span>    array <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span> n);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入数据（用空格分隔）：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>array[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">RadixSort</span>(array);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;排序后为：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, array[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="第九章-查找">
  第九章 查找
  <a class="anchor" href="#%e7%ac%ac%e4%b9%9d%e7%ab%a0-%e6%9f%a5%e6%89%be">#</a>
</h2>
<blockquote>
<p>查找包括：</p>
</blockquote>
<ul>
<li>顺序查找</li>
<li>散列查找</li>
<li>二分查找</li>
</ul>
<hr>
<p>顺序查找想必大家都知道，就是从头到尾比较数据集中的每一个数据，以此来获得想要的数据，但当数据集中拥有的数据较多时，这种方法的效率就会很低。</p>
<p>二分查找是比顺序查找效率高的一种查找算法，但它只适用于有序的数据集。</p>
<h3 id="91-二分查找">
  9.1 二分查找
  <a class="anchor" href="#91-%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be">#</a>
</h3>
<h4 id="911-算法步骤">
  9.1.1 算法步骤
  <a class="anchor" href="#911-%e7%ae%97%e6%b3%95%e6%ad%a5%e9%aa%a4">#</a>
</h4>
<p>二分查找也叫折半查找，它的查找步骤为：</p>
<ul>
<li>（1）首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；</li>
<li>（2）否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。</li>
<li>（3）重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功，如下图所示。</li>
</ul>
<h4 id="912-算法实现">
  9.1.2 算法实现
  <a class="anchor" href="#912-%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0">#</a>
</h4>
<p>二分查找函数需要的参数：</p>
<ul>
<li><code>int *array</code>：目标数组，在这个数组中进行查找</li>
<li><code>int key</code>：待查找的关键字</li>
<li><code>int low</code>、<code>int high</code>：查找的区间；若在整个数组中查找，调用时指定 <code>low</code> 为 0，<code>high</code> 为数组的长度。</li>
</ul>
<p>执行的流程：</p>
<ul>
<li>若 <code>key == array[mid]</code>，查找成功</li>
<li>若 <code>key &lt; array[mid]</code>，则 <code>high = mid-1</code>，进行前一子表查找</li>
<li>若 <code>key &gt; array[mid]</code>，则 <code>low = mid+1</code>，进行后一字表查找</li>
</ul>
<p>二分查找函数的实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 若找到，则函数值为该元素在表中的位置，否则为 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">BinarySearch</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array, <span style="color:#66d9ef">int</span> key, <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> mid;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;=</span> high)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        mid <span style="color:#f92672">=</span> (low <span style="color:#f92672">+</span> high) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> array[mid])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> mid;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">&lt;</span> array[mid])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 前一子表查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            high <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 后一字表查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            low <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 表中不存在待查元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="913-完整代码">
  9.1.3 完整代码
  <a class="anchor" href="#913-%e5%ae%8c%e6%95%b4%e4%bb%a3%e7%a0%81">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">BinarySearch</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array, <span style="color:#66d9ef">int</span> key, <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> mid;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;=</span> high)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        mid <span style="color:#f92672">=</span> (low <span style="color:#f92672">+</span> high) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> array[mid])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> mid;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">&lt;</span> array[mid])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            high <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            low <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n, i, key, position;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入有序数组的大小：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
</span></span><span style="display:flex;"><span>    array <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>) <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span> n);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请按升序输入数据：</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>array[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入想要查找的数：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>key);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (position <span style="color:#f92672">=</span> <span style="color:#a6e22e">BinarySearch</span>(array, key, <span style="color:#ae81ff">0</span>, n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) 
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d的位置为：%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, key, position);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d不存在</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, key);    
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="92-散列查找">
  9.2 散列查找
  <a class="anchor" href="#92-%e6%95%a3%e5%88%97%e6%9f%a5%e6%89%be">#</a>
</h3>
<h4 id="921-散列函数的构造">
  9.2.1 散列函数的构造
  <a class="anchor" href="#921-%e6%95%a3%e5%88%97%e5%87%bd%e6%95%b0%e7%9a%84%e6%9e%84%e9%80%a0">#</a>
</h4>
<p>要构造哈希表首先需要有散列函数，并且这个散列函数需要尽可能地减少冲突，通常有下面几种构造方法：</p>
<h5 id="9211-直接定址法">
  9.2.1.1 直接定址法
  <a class="anchor" href="#9211-%e7%9b%b4%e6%8e%a5%e5%ae%9a%e5%9d%80%e6%b3%95">#</a>
</h5>
<p>我们通过一个例子来讲解，如果我们现在要对 0-20 岁的进行人口统计，那么我们对年龄这个关键字就可以直接用年龄的数字作为地址。此时 f(key) = key。</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180843.png" alt="image-20200414105635398" /></p>
<p>这个时候，我们可以得出这么个哈希函数：f(0) = 0，f(1) = 1，……，f(20) = 20。这个是根据我们自己设定的直接定址来的。人数我们可以不管，我们关心的是如何通过关键字找到地址。</p>
<p>如果我们现在要统计的是 80 后出生年份的人口数，那么我们对出生年份这个关键字可以用年份减去 1980 来作为地址。此时 f (key) = key-1980。</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180846.png" alt="image-20200414105818806" /></p>
<p>假如今年是 2000 年，那么 1980 年出生的人就是 20 岁了，此时 f(2000) = 2000 - 1980，可以找得到地址 20，地址 20 里保存了数据“人数 500 万”。</p>
<p>也就是说，我们可以取关键字的某个线性函数值为散列地址，即：</p>
<pre tabindex="0"><code>f(key) = a × key + b
</code></pre><p>这样的散列函数优点就是简单、均匀，也不会产生冲突，但问题是这需要事先知道关键字的分布情况，适合査找表较小且连续的情况。由于这样的限制，在现实应用中，直接定址法虽然简单，但却并不常用。</p>
<h5 id="9212-数字分析法">
  9.2.1.2 数字分析法
  <a class="anchor" href="#9212-%e6%95%b0%e5%ad%97%e5%88%86%e6%9e%90%e6%b3%95">#</a>
</h5>
<p>数字分析法是在知道关键字的情况下，取关键字的尽量不重复的几位值组成散列地址。</p>
<h5 id="9213-平方取中法">
  9.2.1.3 平方取中法
  <a class="anchor" href="#9213-%e5%b9%b3%e6%96%b9%e5%8f%96%e4%b8%ad%e6%b3%95">#</a>
</h5>
<p>平方取中法就是取关键字平方后的中间几位为散列地址。</p>
<h5 id="9214-折叠法">
  9.2.1.4 折叠法
  <a class="anchor" href="#9214-%e6%8a%98%e5%8f%a0%e6%b3%95">#</a>
</h5>
<p>折叠法是将关键字分为位数相等的几部分，最后一部分的位数可以不等，然后把这几部分的值（舍去进位）相加作为散列地址。</p>
<h5 id="9215-除留余数法">
  9.2.1.5 除留余数法
  <a class="anchor" href="#9215-%e9%99%a4%e7%95%99%e4%bd%99%e6%95%b0%e6%b3%95">#</a>
</h5>
<p>除留余数法此方法为最常用的构造散列函数方法。对于散列表长为 m 的散列函数公式为：</p>
<pre tabindex="0"><code>f( key ) = key mod p ( p ≤ m )
</code></pre><p>mod 是取模（求余数）的意思。事实上，这方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。</p>
<p>很显然，本方法的关键就在于选择合适的 p，p 如果选得不好，就可能会容易产生同义词。下面我们来举个例子看看：</p>
<p>有一个关键字，它有 12 个记录，现在我们要针对它设计一个散列表。如果采用除留余数法，那么可以先尝试将散列函数设计为 f(key) = key mod 12 的方法。比如 29 mod 12 = 5，所以它存储在下标为 5 的位置。</p>
<p><img src="../images/image-20200414110333933.png" alt="image-20200414110333933" /></p>
<p>不过这也是存在冲突的可能的，因为 12=2×6=3×4。如果关键字中有像 18(3×6)、30(5×6)、42(7×6)等数字，它们的余数都为 6，这就和 78 所对应的下标位置冲突了。</p>
<p>使用除留余数法的一个经验是，若散列表表长为 m，通常 p 为小于或等于表长（最好接近 m)的最小质数或不包含小于 20 质因子的合数。实践证明，当 P 取小于散列表长的最大质数时，产生的散列函数较好。</p>
<h5 id="9216-随机数法">
  9.2.1.6 随机数法
  <a class="anchor" href="#9216-%e9%9a%8f%e6%9c%ba%e6%95%b0%e6%b3%95">#</a>
</h5>
<p>随机数法是选择一个随机函数，取关键字的随机函数值作为散列地址。</p>
<h4 id="922-处理冲突">
  9.2.2 处理冲突
  <a class="anchor" href="#922-%e5%a4%84%e7%90%86%e5%86%b2%e7%aa%81">#</a>
</h4>
<p>前面在散列函数的构造中我们发现散列地址可能会产生冲突，所以处理冲突也是构造散列表中重要的一部分，通常处理冲突的方法有下面几种：</p>
<h5 id="9221-开放定址法">
  9.2.2.1 开放定址法
  <a class="anchor" href="#9221-%e5%bc%80%e6%94%be%e5%ae%9a%e5%9d%80%e6%b3%95">#</a>
</h5>
<p>所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入，公式为：</p>
<pre tabindex="0"><code>fi(key) = (f(key)+di) MOD m (di=1,2,3,...,m-1)
</code></pre><p>用开放定址法解决冲突的做法是：</p>
<p>当冲突发生时，使用某种探测技术在散列表中形成一个探测序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址（即该地址单元为空）为止（若要插入，在探查到开放的地址，则可将待插入的新结点存入该地址单元）。查找时探测到开放的地址则表明表中无待查的关键字，即查找失败。</p>
<p>比如说，我们的关键字集合为{12,67,56,16,25,37,22,29,15,47,48,34}，表长为 12。 我们用散列函数 f(key) = key mod l2。</p>
<p>当计算前 S 个数{12,67,56,16,25}时，都是没有冲突的散列地址，直接存入：</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180852.png" alt="image-20200414110735223" /></p>
<p>计算 key = 37 时，发现 f(37) = 1，此时就与 25 所在的位置冲突。</p>
<p>于是我们应用上面的公式 f(37) = (f(37)+1) mod 12 = 2。于是将 37 存入下标为 2 的位置。这其实就是房子被人买了于是买下一间的作法：</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180856.png" alt="image-20200414110824613" /></p>
<p>接下来 22,29,15,47 都没有冲突，正常的存入：</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180900.png" alt="image-20200414110913189" /></p>
<p>到了 key=48，我们计算得到 f(48) = 0，与 12 所在的 0 位置冲突了，不要紧，我们 f(48) = (f(48)+1) mod 12 = 1，此时又与 25 所在的位置冲突。于是 f(48) = (f(48)+2) mod 12=2，还是冲突……一直到 f(48) = (f(48)+6) mod 12 = 6 时，才有空位，机不可失，赶快存入：</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180903.png" alt="image-20200414110949385" /></p>
<p>我们把这种解决冲突的开放定址法称为线性探测法。</p>
<h5 id="9222-二次探测法">
  9.2.2.2 二次探测法
  <a class="anchor" href="#9222-%e4%ba%8c%e6%ac%a1%e6%8e%a2%e6%b5%8b%e6%b3%95">#</a>
</h5>
<p>考虑深一步，如果发生这样的情况，当最后一个 key=34，f(key)=10，与 22 所在的位置冲突，可是 22 后面没有空位置了，反而它的前面有一个空位置，尽管可以不断地求余数后得到结果，但效率很差。</p>
<p>因此我们可以改进 di = 12, -12, 22, -22,……, q2, -q2 (q &lt;= m/2)，这样就等于是可以双向寻找到可能的空位置。</p>
<p>对于 34 来说，我们取 di 即可找到空位置了。另外增加平方运算的目的是为了不让关键字都聚集在某一块区域。我们称这种方法为二次探测法。</p>
<pre tabindex="0"><code>fi(key) = (f(key)+di) MOD m (di = 12, -12, 22, -22,……, q2, -q2, q &lt;= m/2)
</code></pre><h5 id="9223-随机探测法">
  9.2.2.3 随机探测法
  <a class="anchor" href="#9223-%e9%9a%8f%e6%9c%ba%e6%8e%a2%e6%b5%8b%e6%b3%95">#</a>
</h5>
<p>还有一种方法，是在冲突时，对于位移量 di 采用随机函数计算得到，我们称之为随机探测法。此时一定会有人问，既然是随机，那么查找的时候不也随机生成吗？如何可以获得相同的地址呢？这是个问题。这里的随机其实是伪随机数。</p>
<p>伪随机数是说，如果我们设置随机种子相同，则不断调用随机函数可以生成不会重复的数列，我们在査找时，用同样的随机种子，它每次得到的数列是相同的，相同的 di 当然可以得到相同的散列地址。</p>
<pre tabindex="0"><code>fi(key) = (f(key)+di) MOD m (di 是一个随机数列)
</code></pre><p>总之，开放定址法只要在散列表未填满时，总是能找到不发生冲突的地址，是我们常用的解决冲突的办法。</p>
<h5 id="9224-再哈希法">
  9.2.2.4 再哈希法
  <a class="anchor" href="#9224-%e5%86%8d%e5%93%88%e5%b8%8c%e6%b3%95">#</a>
</h5>
<p>再哈希法是：当散列地址冲突时，用另外一个散列函数再计算一次，这种方法减少了冲突，但增加了计算的时间。</p>
<h5 id="9225-链地址法">
  9.2.2.5 链地址法
  <a class="anchor" href="#9225-%e9%93%be%e5%9c%b0%e5%9d%80%e6%b3%95">#</a>
</h5>
<p>前面我们谈到了散列冲突处理的开放定址法，它的思路就是一旦发生了冲突，就去寻找下一个空的散列地址。那么，有冲突就非要换地方吗？我们直接就在原地处理行不行呢？可以的，于是我们就有了链地址法：</p>
<p>将所有关键字散列地址相同的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。</p>
<p>对于关键字集合{12,67,56,16,25,37, 22,29,15,47,48,34}，我们用 12 为除数，进行除留余数法：</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180908.png" alt="image-20200414111305968" /></p>
<p>此时，已经不存在什么冲突换址的问题，无论有多少个冲突，都只是在当前位置给单链表增加结点的问题。链地址法解决冲突的做法是：将所有关键字散列地址相同的结点链接在同一个单链表中。若选定的散列表长度为 m，则可将散列表定义为一个由 m 个头指针组成的指针数组 T[0..m-1]。凡是散列地址为 i 的结点，均插入到以 T[i] 为头指针的单链表中。T 中各分量的初值均应为空指针。在拉链法中，装填因子 α 可以大于 1，但一般均取α≤1。</p>
<p>链地址法的优势是对于可能会造成很多冲突的散列函数来说，提供了绝不会出现找不到地址的保障。当然，这也就带来了査找时需要遍历单链表的性能损耗，不过性能损耗在很多场合下也不是什么大问题。</p>
<h5 id="9226-建立公共溢出区">
  9.2.2.6 建立公共溢出区
  <a class="anchor" href="#9226-%e5%bb%ba%e7%ab%8b%e5%85%ac%e5%85%b1%e6%ba%a2%e5%87%ba%e5%8c%ba">#</a>
</h5>
<p>这种方法的基本思想是：将散列表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p>
<h2 id="第十章-不相交集">
  第十章 不相交集
  <a class="anchor" href="#%e7%ac%ac%e5%8d%81%e7%ab%a0-%e4%b8%8d%e7%9b%b8%e4%ba%a4%e9%9b%86">#</a>
</h2>
<h2 id="第十一章-图论算法">
  第十一章 图论算法
  <a class="anchor" href="#%e7%ac%ac%e5%8d%81%e4%b8%80%e7%ab%a0-%e5%9b%be%e8%ae%ba%e7%ae%97%e6%b3%95">#</a>
</h2>
<h2 id="第十二章-算法设计技巧">
  第十二章 算法设计技巧
  <a class="anchor" href="#%e7%ac%ac%e5%8d%81%e4%ba%8c%e7%ab%a0-%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e6%8a%80%e5%b7%a7">#</a>
</h2>
<h2 id="第十三章-摊还分析">
  第十三章 摊还分析
  <a class="anchor" href="#%e7%ac%ac%e5%8d%81%e4%b8%89%e7%ab%a0-%e6%91%8a%e8%bf%98%e5%88%86%e6%9e%90">#</a>
</h2>
<h2 id="第十四章-高级数据结构及其实现">
  第十四章 高级数据结构及其实现
  <a class="anchor" href="#%e7%ac%ac%e5%8d%81%e5%9b%9b%e7%ab%a0-%e9%ab%98%e7%ba%a7%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%8f%8a%e5%85%b6%e5%ae%9e%e7%8e%b0">#</a>
</h2>
<h2 id="矩阵的压缩存储">
  矩阵的压缩存储
  <a class="anchor" href="#%e7%9f%a9%e9%98%b5%e7%9a%84%e5%8e%8b%e7%bc%a9%e5%ad%98%e5%82%a8">#</a>
</h2>
<h3 id="对称矩阵">
  对称矩阵
  <a class="anchor" href="#%e5%af%b9%e7%a7%b0%e7%9f%a9%e9%98%b5">#</a>
</h3>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180913.png" alt="" /></p>
<p>计算$$\large a_{i,j}$$在压缩矩阵中的下标</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180916.png" alt="" /></p>
<h3 id="三角矩阵">
  三角矩阵
  <a class="anchor" href="#%e4%b8%89%e8%a7%92%e7%9f%a9%e9%98%b5">#</a>
</h3>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180919.png" alt="" /></p>
<p>+1个空间是为了存储这个常数c</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180922.png" alt="" /></p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180924.png" alt="" /></p>
<h3 id="三对角矩阵">
  三对角矩阵
  <a class="anchor" href="#%e4%b8%89%e5%af%b9%e8%a7%92%e7%9f%a9%e9%98%b5">#</a>
</h3>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180927.png" alt="" /></p>
<p>数组下标$$k=3*(i-1)-1+j-i+1=2*i+j-3$$</p>
<p>$$i = (k+1)/3 + 1$$</p>
<p>$$j = k-2*i+3$$</p>
<h3 id="稀疏矩阵">
  稀疏矩阵
  <a class="anchor" href="#%e7%a8%80%e7%96%8f%e7%9f%a9%e9%98%b5">#</a>
</h3>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180931.png" alt="" /></p>
<blockquote>
<p>稀疏矩阵在采用压缩存储后将会<strong>失去随机存储的功能</strong>。因为在这种矩阵中，非零元素的分布是没有规律的，为了压缩存储，就将每一个非零元素的值和它所在的行、列号做为一个结点存放在一起，这样的结点组成的线性表中叫三元组表，它已不是简单的向量，所以无法用下标直接存取矩阵中的元素。</p>
</blockquote>
<h2 id="kmp算法">
  KMP算法
  <a class="anchor" href="#kmp%e7%ae%97%e6%b3%95">#</a>
</h2>
<p>理解三个概念：前缀、后缀、部分匹配值</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180934.png" alt="" /></p>
<h3 id="手搓步骤">
  手搓步骤
  <a class="anchor" href="#%e6%89%8b%e6%90%93%e6%ad%a5%e9%aa%a4">#</a>
</h3>
<p>计算模式串中所有前缀的部分匹配值</p>
<p><img src="https://gitee.com/wugenqiang/PictureBed/raw/master/CS-Notes/20200428180938.png" alt="" /></p>
<p>匹配成功则向后推进，匹配失败则根据next[]数组回退（j-1 - next[j-1]）步。</p>
<p><img src="https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200319005345.png" alt="" /></p>
<h3 id="算法实现">
  算法实现
  <a class="anchor" href="#%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">KMP2</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> next<span style="color:#f92672">[]</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> String pat;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        KMP2 kmp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> KMP2(<span style="color:#e6db74">&#34;issip&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> kmp.<span style="color:#a6e22e">search</span>(<span style="color:#e6db74">&#34;mississippi&#34;</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;res: &#34;</span> <span style="color:#f92672">+</span> res);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">KMP2</span>(String pat) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">pat</span> <span style="color:#f92672">=</span> pat;
</span></span><span style="display:flex;"><span>        getNext(pat);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">getNext</span>(String pat) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> p <span style="color:#f92672">=</span> pat.<span style="color:#a6e22e">toCharArray</span>();
</span></span><span style="display:flex;"><span>        next <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>p.<span style="color:#a6e22e">length</span><span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        next<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&lt;</span> p.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (k <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>1 <span style="color:#f92672">||</span> p<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> p<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span>) {
</span></span><span style="display:flex;"><span>                next<span style="color:#f92672">[++</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>k;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                k <span style="color:#f92672">=</span> next<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">search</span>(String text) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> t <span style="color:#f92672">=</span> text.<span style="color:#a6e22e">toCharArray</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> p <span style="color:#f92672">=</span> pat.<span style="color:#a6e22e">toCharArray</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; <span style="color:#75715e">// 主串位置</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0; <span style="color:#75715e">// 模式串位置</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> t.<span style="color:#a6e22e">length</span> <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;</span> p.<span style="color:#a6e22e">length</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>1 <span style="color:#f92672">||</span> t<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> p<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span>) {
</span></span><span style="display:flex;"><span>                i<span style="color:#f92672">++</span>; j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                j <span style="color:#f92672">=</span> next<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span>; <span style="color:#75715e">// j回退</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> p.<span style="color:#a6e22e">length</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> i<span style="color:#f92672">-</span>j;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>1;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>利用动态规划 二维dp 实现KMP算法</p>
<p><a href="https://www.zhihu.com/question/31634405">有限状态机</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/83334559">labuladong KMP算法详解</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">KMP</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[][]</span> dp;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> String pat;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        KMP kmp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> KMP(<span style="color:#e6db74">&#34;issip&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> kmp.<span style="color:#a6e22e">search</span>(<span style="color:#e6db74">&#34;mississippi&#34;</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;res: &#34;</span> <span style="color:#f92672">+</span> res);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">KMP</span>(String pat) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">pat</span> <span style="color:#f92672">=</span> pat;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> M <span style="color:#f92672">=</span> pat.<span style="color:#a6e22e">length</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// dp[状态][字符] = 下个状态</span>
</span></span><span style="display:flex;"><span>        dp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>M<span style="color:#f92672">][</span>256<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// base case</span>
</span></span><span style="display:flex;"><span>        dp<span style="color:#f92672">[</span>0<span style="color:#f92672">][</span>pat.<span style="color:#a6e22e">charAt</span>(0)<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 影子状态 X 初始为 0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> X <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 构建状态转移图（稍改的更紧凑了）</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 1; j <span style="color:#f92672">&lt;</span> M; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> 0; c <span style="color:#f92672">&lt;</span> 256; c<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (pat.<span style="color:#a6e22e">charAt</span>(j) <span style="color:#f92672">==</span> c) {
</span></span><span style="display:flex;"><span>                    dp<span style="color:#f92672">[</span>j<span style="color:#f92672">][</span>c<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> j <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    dp<span style="color:#f92672">[</span>j<span style="color:#f92672">][</span>c<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> dp<span style="color:#f92672">[</span>X<span style="color:#f92672">][</span>c<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 更新影子状态</span>
</span></span><span style="display:flex;"><span>            X <span style="color:#f92672">=</span> dp<span style="color:#f92672">[</span>X<span style="color:#f92672">][</span>pat.<span style="color:#a6e22e">charAt</span>(j)<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">search</span>(String txt) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> M <span style="color:#f92672">=</span> pat.<span style="color:#a6e22e">length</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> txt.<span style="color:#a6e22e">length</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// pat 的初始态为 0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> N; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 计算 pat 的下一个状态</span>
</span></span><span style="display:flex;"><span>            j <span style="color:#f92672">=</span> dp<span style="color:#f92672">[</span>j<span style="color:#f92672">][</span>txt.<span style="color:#a6e22e">charAt</span>(i)<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 到达终止态，返回结果</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> M) <span style="color:#66d9ef">return</span> i <span style="color:#f92672">-</span> M <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 没到达终止态，匹配失败</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="回溯算法">
  回溯算法
  <a class="anchor" href="#%e5%9b%9e%e6%ba%af%e7%ae%97%e6%b3%95">#</a>
</h2>
<h3 id="八皇后问题">
  八皇后问题
  <a class="anchor" href="#%e5%85%ab%e7%9a%87%e5%90%8e%e9%97%ae%e9%a2%98">#</a>
</h3>
<p>该问题是十九世纪著名的数学家高斯1850年提出：
在8*8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#第一章-引论">第一章 引论</a>
      <ul>
        <li><a href="#11-数学知识复习">1.1 数学知识复习</a></li>
        <li><a href="#12-递归简论">1.2 递归简论</a></li>
        <li><a href="#13-数据结构的概念">1.3 数据结构的概念</a></li>
      </ul>
    </li>
    <li><a href="#第二章-算法分析">第二章 算法分析</a>
      <ul>
        <li><a href="#21-算法的概念">2.1 算法的概念</a></li>
        <li><a href="#22-数学基础">2.2 数学基础</a></li>
        <li><a href="#23-计算模型">2.3 计算模型</a></li>
        <li><a href="#24-算法效率的度量">2.4 算法效率的度量</a></li>
        <li><a href="#25-分析问题">2.5 分析问题</a></li>
      </ul>
    </li>
    <li><a href="#第三章-线性表">第三章 线性表</a>
      <ul>
        <li><a href="#31-抽象数据类型adt">3.1 抽象数据类型(ADT)</a></li>
        <li><a href="#32-顺序表">3.2 顺序表</a></li>
        <li><a href="#33-链式表">3.3 链式表</a></li>
      </ul>
    </li>
    <li><a href="#第四章-栈和队列">第四章 栈和队列</a>
      <ul>
        <li><a href="#41-栈">4.1 栈</a></li>
        <li><a href="#42-队列">4.2 队列</a></li>
      </ul>
    </li>
    <li><a href="#第五章-树">第五章 树</a>
      <ul>
        <li><a href="#基本概念">基本概念</a></li>
        <li><a href="#树的性质">树的性质</a></li>
        <li><a href="#二叉树定义">二叉树定义</a></li>
        <li><a href="#二叉树性质">二叉树性质</a></li>
        <li><a href="#二叉树存储">二叉树存储</a></li>
        <li><a href="#二叉树遍历">二叉树遍历</a></li>
        <li><a href="#遍历序列构造二叉树">遍历序列构造二叉树</a></li>
        <li><a href="#线索二叉树">线索二叉树</a></li>
        <li><a href="#树的存储">树的存储</a></li>
        <li><a href="#树森林与二叉树的转换">树、森林与二叉树的转换</a></li>
        <li><a href="#树的遍历">树的遍历</a></li>
        <li><a href="#森林的遍历">森林的遍历</a></li>
        <li><a href="#遍历序列的对应关系">遍历序列的对应关系</a></li>
        <li><a href="#树的应用-并查集">树的应用-并查集</a></li>
        <li><a href="#树的应用-二叉排序树">树的应用-二叉排序树</a></li>
      </ul>
    </li>
    <li><a href="#第六章-散列">第六章 散列</a></li>
    <li><a href="#第七章-优先队列堆">第七章 优先队列（堆）</a></li>
    <li><a href="#第八章-排序">第八章 排序</a>
      <ul>
        <li><a href="#81--排序算法简述">8.1  排序算法简述</a></li>
        <li><a href="#82-插入排序">8.2 插入排序</a></li>
        <li><a href="#83-交换排序">8.3 交换排序</a></li>
        <li><a href="#84-选择排序">8.4 选择排序</a></li>
        <li><a href="#85-归并排序">8.5 归并排序</a></li>
        <li><a href="#86-基数排序">8.6 基数排序</a></li>
      </ul>
    </li>
    <li><a href="#第九章-查找">第九章 查找</a>
      <ul>
        <li><a href="#91-二分查找">9.1 二分查找</a></li>
        <li><a href="#92-散列查找">9.2 散列查找</a></li>
      </ul>
    </li>
    <li><a href="#第十章-不相交集">第十章 不相交集</a></li>
    <li><a href="#第十一章-图论算法">第十一章 图论算法</a></li>
    <li><a href="#第十二章-算法设计技巧">第十二章 算法设计技巧</a></li>
    <li><a href="#第十三章-摊还分析">第十三章 摊还分析</a></li>
    <li><a href="#第十四章-高级数据结构及其实现">第十四章 高级数据结构及其实现</a></li>
    <li><a href="#矩阵的压缩存储">矩阵的压缩存储</a>
      <ul>
        <li><a href="#对称矩阵">对称矩阵</a></li>
        <li><a href="#三角矩阵">三角矩阵</a></li>
        <li><a href="#三对角矩阵">三对角矩阵</a></li>
        <li><a href="#稀疏矩阵">稀疏矩阵</a></li>
      </ul>
    </li>
    <li><a href="#kmp算法">KMP算法</a>
      <ul>
        <li><a href="#手搓步骤">手搓步骤</a></li>
        <li><a href="#算法实现">算法实现</a></li>
      </ul>
    </li>
    <li><a href="#回溯算法">回溯算法</a>
      <ul>
        <li><a href="#八皇后问题">八皇后问题</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












